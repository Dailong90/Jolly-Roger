<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Enigma – Regole finali</title>
  <!-- Bootstrap Icons (per il caret e le icone dei pulsanti) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    :root { --bg-url: url('assets/jolly_bay.jpg'); }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body{
      font-family:'Georgia','Times New Roman',serif; color:#2e2e2e;
      background:#000; min-height:100svh; position:relative;
    }
    body::before{ content:""; position:fixed; inset:0; background:var(--bg-url) center/cover no-repeat; z-index:-2; }
    body::after { content:""; position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:-1; }

    .wrap{
      position:fixed; left:50%; top:65svh; transform:translate(-50%,-50%);
      width:min(560px,92vw); padding:16px;
    }
    .card{
      display:flex; flex-direction:column; gap:10px;
      background:#fdf6e3; border:2px solid #d6c29e; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.45), inset 0 0 40px rgba(139,69,19,.25);
      background-image:
        radial-gradient(circle at top left, rgba(255,255,255,0.3), transparent 60%),
        radial-gradient(circle at bottom right, rgba(0,0,0,0.05), transparent 70%);
      max-height:58svh;
    }
    .card__head{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:2px 4px 0; }
    .card__title{ margin:0; font-size:18px; line-height:1.2; color:#3b2c20; }

    /* Box scorrevole con overlay fisse */
    .riddle{
      position:relative; border:1px dashed #b2926d; border-radius:8px; background:rgba(255,255,255,.65);
      display:grid;
    }
    .riddle__scroller{
      grid-area:1 / 1;
      overflow:auto; -webkit-overflow-scrolling:touch;
      padding:14px 16px 32px;
      line-height:1.5; font-size:16px; color:#3b2c20; white-space:pre-wrap;
      max-height:40svh;
    }
    .riddle__fade{
      grid-area:1 / 1; align-self:end; height:72px;
      background:linear-gradient(to top, rgba(253,246,227,0.96), rgba(253,246,227,0));
      border-radius:0 0 8px 8px; pointer-events:none; z-index:2; opacity:1; transition:opacity .2s;
    }
    .riddle__indicator{
      grid-area:1 / 1; justify-self:center; align-self:end; transform:translateY(-10px);
      font-size:26px; color:#6b5b4b; z-index:3; pointer-events:none; opacity:1; transition:opacity .2s;
      animation:bounce 1.2s infinite;
    }
    @keyframes bounce { 0%,100%{ transform:translateY(-10px); } 50%{ transform:translateY(-4px); } }
    .riddle.--no-scroll .riddle__fade, .riddle.--no-scroll .riddle__indicator,
    .riddle.--at-bottom .riddle__fade, .riddle.--at-bottom .riddle__indicator { opacity:0; }

    .btn{
      cursor:pointer; border:1px solid #8b6b1b; border-radius:8px; padding:10px 14px; font-weight:700;
      background:linear-gradient(180deg,#f5d76e,#d4a017); color:#3b2c20; font-family:'Georgia',serif;
      box-shadow:0 3px 6px rgba(0,0,0,.4), inset 0 2px 4px rgba(255,255,255,.4);
      transition:transform .15s, box-shadow .15s; white-space:nowrap;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 5px 8px rgba(0,0,0,.5), inset 0 2px 4px rgba(255,255,255,.5); }

    /* MODALI */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; align-items:center; justify-content:center; padding:4vw; z-index:999; }
    .modal.open{ display:flex; }

    .modal__inner{ position:relative; max-width:92vw; max-height:92vh; width:1200px; background:#111; border-radius:12px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.6); display:flex; flex-direction:column; }
    .modal__close{ position:absolute; top:8px; right:8px; border:none; padding:8px 12px; line-height:1; background:#222; color:#f5d76e; font-weight:700; border-radius:8px; cursor:pointer; }
    .modal__close:hover{ background:#2f2f2f; }

    .board{
      position:relative; flex:1 1 auto; min-height:200px;
      display:block; overflow:hidden; background:#000;
    }
    .board__img{
      display:block; width:100%; height:auto; user-select:none; pointer-events:none;
    }

    /* Pedina singola JR – 9x9 px (colore gestito via classe) */
    .pawn{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width:9px; height:9px; border-radius:50%;
      border:1px solid; color:#063; font-weight:100; font-family:'Georgia',serif;
      display:flex; align-items:center; justify-content:center;
      font-size:4px; letter-spacing:0px;
      box-shadow:0 4px 10px rgba(0,0,0,.45), inset 0 2px 4px rgba(255,255,255,.45);
      cursor:grab; touch-action:none; user-select:none;
    }
    .pawn:active{ cursor:grabbing; }
    
    /* Varianti colore */
    .pawn.green{ background:linear-gradient(180deg,#34d399,#10b981); border-color:#0e8f6f; }
    .pawn.red  { background:linear-gradient(180deg,#f87171,#ef4444); border-color:#991b1b; }
    .pawn.blue { background:linear-gradient(180deg,#60a5fa,#3b82f6); border-color:#1e3a8a; }


    .modal__toolbar{
      display:flex; gap:8px; padding:10px; justify-content:space-between; align-items:center;
      background:#0f0f0f; border-top:1px solid #222;
    }
    .turns{
      color:#ddd; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:.95rem; padding:6px 10px; background:#151515; border:1px solid #2a2a2a; border-radius:8px;
    }
    .toolbar__btn{
      border:1px solid #444; background:#1e1e1e; color:#eee; border-radius:8px; padding:8px 10px; cursor:pointer;
    }
    .toolbar__btn[disabled]{ opacity:.5; cursor:not-allowed; }
    .toolbar__btn:hover:not([disabled]){ background:#2a2a2a; }

    /* Fine partita */
    .end__inner{
      position:relative; max-width:92vw; width:min(520px,92vw); background:#1a1a1a; color:#eee;
      border-radius:12px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.6);
    }
    .end__header{ display:flex; align-items:center; justify-content:space-between; padding:12px 14px; background:#111; }
    .end__body{ padding:16px; line-height:1.5; }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="card" aria-labelledby="titolo-regole">
      <div class="card__head">
        <h2 id="titolo-regole" class="card__title">Regole</h2>
        <button id="btnMap" type="button" class="btn" aria-haspopup="dialog" aria-controls="modalMap">Mappa</button>
      </div>

      <div class="riddle" id="riddleBox">
        <div class="riddle__scroller" id="riddleScroll">
Regole moviemnto Roger

Roger parte del covo dei Jolly, indicato con la bandiera pirata.
Si muove lungo le linea tratteggiate solo sule caselle numerate.
Per nascondere il tesoro Roger deve effettuare esattemamente 15 passi.
I passi vengono effettuati tra caselle numerate adicenti.
Sono considerate adiecenti le caselle numerate collegate dalle linee tratteggiate; i punti neri non valgono per Roger.

Regole movimento cacciatore

Il cacciatore parte del covo dei Jolly, indicato con la bandiera pirata.
Si muove lungo le linea tratteggiate solo sui punti neri tra le caselle numerate.
Ad ogni turno il cacciatore può fare da 0 a 3 passi.
Terminato il movimento si troverà con una o più caselle numerate adiencenti alla sua posizione.
Il cacciatore deve scegliere una casella numerata e chiedere indizi sul passaggio di Roger.
Nel caso la casella sia presente nel percorso di Roger gli verrà risposto di sì.
Nel caso la casella non sia presente nel percorso di Roger gli verrà risposto di no.
L'inizio del turno del cacciatore, riparte dalla posizione in cui si è fermato il turno precedente.
Il cacciatore può continuare la sua ricerca per un totale di 15 turni.
Effettuato un turno, se saranno presenti altre squadre per chiedere un'indizio, si procederà uno alla volta.
Se dopo 15 turni si necessita di altri 15 indizi per trovare il tesoro, il cacciatore dovrà aspettare 5 minuti per ricominciare.
        </div>
        <div class="riddle__fade" aria-hidden="true"></div>
        <div class="riddle__indicator" aria-hidden="true"><i class="bi bi-caret-down-fill"></i></div>
      </div>
    </section>
  </main>

  <!-- MODALE: tabellone + pedina singola -->
  <div id="modalMap" class="modal" role="dialog" aria-modal="true" aria-label="Mappa della caccia al tesoro" aria-hidden="true">
    <div class="modal__inner">
      <button class="modal__close" type="button" id="btnClose" aria-label="Chiudi (Esc)">Chiudi ✕</button>

      <div class="board" id="board">
        <img class="board__img" id="boardImg" src="assets/lucmap25.png" alt="Tabellone di gioco" />
        <!-- Una sola pedina -->
        <div class="pawn green" data-id="JR" title="Pedina JR">JR</div>
      </div>

      <div class="modal__toolbar">
        <div class="turns" id="turnsInfo">Turno: 0 / 15</div>
        <div>
          <label for="pawnColor" style="color:#ddd; font-size:.9rem; margin-right:4px;">Colore:</label>
          <select id="pawnColor" class="toolbar__btn">
            <option value="green">Verde</option>
            <option value="red">Rosso</option>
            <option value="blue">Blu</option>
          </select>
          <button class="toolbar__btn" id="btnSave"><i class="bi bi-save"></i> Salva</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MODALE FINE PARTITA -->
  <div id="modalEnd" class="modal" role="dialog" aria-modal="true" aria-label="Fine partita" aria-hidden="true">
    <div class="end__inner">
      <div class="end__header">
        <strong>Fine partita</strong>
        <button class="modal__close" type="button" id="btnCloseEnd" aria-label="Chiudi">✕</button>
      </div>
      <div class="end__body">
        <p>Hai raggiunto il <strong>15° turno</strong>.</p>
        <p>Puoi resettare per ricominciare dall’inizio.</p>
        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
          <button class="toolbar__btn" id="btnResetAll"><i class="bi bi-arrow-counterclockwise"></i> Reset</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== Modale base ===== */
    const btnMap  = document.getElementById('btnMap');
    const modal   = document.getElementById('modalMap');
    const btnClose= document.getElementById('btnClose');

    function openModal(){ modal.classList.add('open'); modal.setAttribute('aria-hidden','false'); btnClose && btnClose.focus(); }
    function closeModal(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); btnMap && btnMap.focus(); }
    btnMap.addEventListener('click', openModal);
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });

    /* ===== Modale fine partita ===== */
    const modalEnd = document.getElementById('modalEnd');
    const btnCloseEnd = document.getElementById('btnCloseEnd');
    const btnResetAll = document.getElementById('btnResetAll');

    function openEnd(){ modalEnd.classList.add('open'); modalEnd.setAttribute('aria-hidden','false'); }
    function closeEnd(){ modalEnd.classList.remove('open'); modalEnd.setAttribute('aria-hidden','true'); }
    btnCloseEnd?.addEventListener('click', closeEnd);
    modalEnd.addEventListener('click', e => { if (e.target === modalEnd) closeEnd(); });

    // Esc chiude qualunque modale aperta
    window.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        if (modal.classList.contains('open')) closeModal();
        if (modalEnd.classList.contains('open')) closeEnd();
      }
    });

    /* ===== Overlay scroll riddle ===== */
    const riddleBox = document.getElementById('riddleBox');
    const scroller  = document.getElementById('riddleScroll');
    function updateOverlay(){
      const canScroll = scroller.scrollHeight > scroller.clientHeight + 1;
      riddleBox.classList.toggle('--no-scroll', !canScroll);
      const atBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 1;
      riddleBox.classList.toggle('--at-bottom', atBottom);
    }
    scroller.addEventListener('scroll', updateOverlay);
    window.addEventListener('load', () => requestAnimationFrame(updateOverlay));
    window.addEventListener('resize', () => requestAnimationFrame(updateOverlay));

    /* ===== Board con pedina trascinabile (singola JR) ===== */
    const board = document.getElementById('board');
    const boardImg = document.getElementById('boardImg');
    const pawns = Array.from(board.querySelectorAll('.pawn'));

    const STORAGE_KEY = 'enigma_board_pawnJR_v1';
    const TURNS_KEY   = 'enigma_board_turns_v1';
    const COLOR_KEY   = 'enigma_board_pawnColor_v1';
    const TURN_LIMIT  = 15;

    // posizione in percentuale {JR:{x,y}} – punto iniziale richiesto
    const defaultPos = { JR:{x:9.3,y:42.2} };
    let state = loadState() || defaultPos;
    let lastSaved = clone(state);
    let turns = loadTurns(); // 0 ... 15
    let currentColor = loadColor(); // 'green' | 'red' | 'blue'

    const turnsInfo = document.getElementById('turnsInfo');
    const btnSave   = document.getElementById('btnSave');
    const colorSelect = document.getElementById('pawnColor');

    function clone(o){ return JSON.parse(JSON.stringify(o)); }

    function loadState(){
      try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)); }catch(e){ return null; }
    }
    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    function loadTurns(){
      const n = parseInt(localStorage.getItem(TURNS_KEY), 10);
      return Number.isFinite(n) && n >= 0 ? n : 0;
    }
    function saveTurns(){
      localStorage.setItem(TURNS_KEY, String(turns));
    }

    function loadColor(){
      const c = localStorage.getItem(COLOR_KEY);
      return (c === 'red' || c === 'blue' || c === 'green') ? c : 'green';
    }
    function saveColor(){
      localStorage.setItem(COLOR_KEY, currentColor);
    }
    function applyColor(){
      pawns.forEach(p => {
        p.classList.remove('green','red','blue');
        p.classList.add(currentColor);
      });
    }
    
    function applyPositions(){
      pawns.forEach(p => {
        const id = p.dataset.id; // 'JR'
        const pos = state[id] || defaultPos[id];
        p.style.left = pos.x + '%';
        p.style.top  = pos.y + '%';
      });
      applyColor();
    }

    function updateUI(){
      turnsInfo.textContent = `Turno: ${turns} / ${TURN_LIMIT}`;
      btnSave.disabled = (turns >= TURN_LIMIT);
      if (colorSelect) colorSelect.value = currentColor;
    }

    // Drag & drop con Pointer Events (mouse + touch)
    pawns.forEach(pawn => {
      pawn.addEventListener('pointerdown', (ev) => {
        ev.preventDefault();
        pawn.setPointerCapture(ev.pointerId);

        const onMove = (e) => {
          const rect = board.getBoundingClientRect();
          const cx = (e.clientX - rect.left) / rect.width * 100;
          const cy = (e.clientY - rect.top)  / rect.height * 100;
          const x = Math.min(98, Math.max(2, cx));
          const y = Math.min(98, Math.max(2, cy));
          pawn.style.left = x + '%';
          pawn.style.top  = y + '%';
          state[pawn.dataset.id] = {x, y};
        };

        const onUp = (e) => {
          pawn.releasePointerCapture(e.pointerId);
          // non salviamo automaticamente: si conta il turno solo col pulsante Salva
          pawn.removeEventListener('pointermove', onMove);
          pawn.removeEventListener('pointerup', onUp);
          pawn.removeEventListener('pointercancel', onUp);
        };

        pawn.addEventListener('pointermove', onMove);
        pawn.addEventListener('pointerup', onUp);
        pawn.addEventListener('pointercancel', onUp);
      });
    });

    // Aggiunta listener del select //
    colorSelect.addEventListener('change', () => {
      currentColor = colorSelect.value;
      applyColor();
      saveColor();
    });

    
    // Bottone SALVA: salva posizione e, se diversa dall'ultima salvata, incrementa il turno
    btnSave.addEventListener('click', () => {
      if (turns >= TURN_LIMIT) {
        updateUI();
        openEnd();
        return;
      }

      // confronto “prima vs adesso”
      const changed = JSON.stringify(state) !== JSON.stringify(lastSaved);
      saveState(); // salviamo comunque la posizione corrente

      if (changed) {
        turns = Math.min(TURN_LIMIT, turns + 1);
        saveTurns();
        lastSaved = clone(state);
      }

      updateUI();

      if (turns >= TURN_LIMIT) {
        openEnd();
      }
    });

    // Reset totale dalla modale di fine partita
    btnResetAll.addEventListener('click', () => {
      // reset posizione
      state = clone(defaultPos);
      applyPositions();
      saveState();
      lastSaved = clone(state);

      // reset turni
      turns = 0;
      saveTurns();
      updateUI();

      closeEnd();
    });

    // Aggiorna posizioni/turni all'avvio
    boardImg.addEventListener('load', () => { applyPositions(); updateUI(); });
    if (boardImg.complete) { applyPositions(); updateUI(); }
    window.addEventListener('resize', applyPositions);
  </script>
</body>
</html>
