<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Enigma – Combinazione</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    :root { --bg-url: url('assets/temp_o2.png'); --ok:#10b981; --err:#ef4444; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body{
      font-family:'Georgia','Times New Roman',serif; color:#2e2e2e;
      background:#000; min-height:100svh; position:relative;
    }
    body::before{ content:""; position:fixed; inset:0; background:var(--bg-url) center/cover no-repeat; z-index:-2; }
    body::after { content:""; position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:-1; }

    .wrap{
      position:fixed; left:50%; top:65svh; transform:translate(-50%,-50%);
      width:min(560px,92vw); padding:16px;
    }

    .card{
      display:flex; flex-direction:column; gap:10px;
      background:#fdf6e3; border:2px solid #d6c29e; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.45), inset 0 0 40px rgba(139,69,19,.25);
      background-image:
        radial-gradient(circle at top left, rgba(255,255,255,0.3), transparent 60%),
        radial-gradient(circle at bottom right, rgba(0,0,0,0.05), transparent 70%);
      max-height:58svh; overflow:hidden;
      transition: opacity .28s ease, transform .28s ease, visibility 0s linear .28s;
    }
    .card.is-hidden{ opacity:0; transform: translateY(10px) scale(.98); pointer-events:none; visibility:hidden; }
    .card:not(.is-hidden){ opacity:1; transform:none; visibility:visible; transition-delay:0s; }

    .btn--big{
      position: fixed; left:16px; bottom:16px; width:auto; margin:0;
      text-align:center; font-size:18px; padding:12px 16px; z-index:1000;
    }

    .head__actions{ display:flex; gap:8px; }

    .btn{
      cursor:pointer; border:1px solid #8b6b1b; border-radius:8px; padding:10px 14px; font-weight:700;
      background:linear-gradient(180deg,#f5d76e,#d4a017); color:#3b2c20; font-family:'Georgia',serif;
      box-shadow:0 3px 6px rgba(0,0,0,.4), inset 0 2px 4px rgba(255,255,255,.4);
      transition:transform .15s, box-shadow .15s; white-space:nowrap;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 5px 8px rgba(0,0,0,.5), inset 0 2px 4px rgba(255,255,255,.5); }
    .btn.btn--ghost{
      background:#efe6c7; border-color:#b2926d;
      box-shadow:0 2px 4px rgba(0,0,0,.2), inset 0 2px 3px rgba(255,255,255,.35);
    }

    .card__head{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:2px 4px 0; }
    .card__title{ margin:0; font-size:18px; line-height:1.2; color:#3b2c20; }

    .riddle{
      position:relative; border:1px dashed #b2926d; border-radius:8px; background:rgba(255,255,255,.65);
      display:grid; flex:1; min-height:0;
    }
    .riddle__scroller{
      grid-area:1 / 1; overflow:auto; -webkit-overflow-scrolling:touch;
      padding:14px 16px 32px; line-height:1.5; font-size:16px; color:#3b2c20; white-space:pre-wrap; min-height:0;
    }
    .riddle__fade{
      grid-area:1 / 1; align-self:end; height:84px;
      background:linear-gradient(to top, rgba(253,246,227,0.96), rgba(253,246,227,0));
      border-radius:0 0 8px 8px; pointer-events:none; z-index:2; opacity:1; transition:opacity .2s ease;
    }
    .riddle__indicator{
      grid-area:1 / 1; justify-self:center; align-self:end; transform:translateY(-10px);
      font-size:26px; color:#6b5b4b; z-index:3; pointer-events:none; animation:bounce 1.2s infinite; opacity:1; transition:opacity .2s ease;
    }
    @keyframes bounce { 0%,100%{ transform:translateY(-10px); } 50%{ transform:translateY(-4px); } }
    .riddle.--no-scroll .riddle__fade,
    .riddle.--no-scroll .riddle__indicator,
    .riddle.--at-bottom .riddle__fade,
    .riddle.--at-bottom .riddle__indicator { opacity:0; }

    /* ===== Modale ===== */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; align-items:center; justify-content:center; padding:4vw; z-index:999; }
    .modal.open{ display:flex; }
    .modal__inner{ position:relative; max-width:92vw; max-height:92vh; width:1200px; background:#111; border-radius:12px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.6); }
    .modal__close{ position:absolute; top:8px; right:8px; border:none; padding:8px 12px; line-height:1; background:#222; color:#f5d76e; font-weight:700; border-radius:8px; cursor:pointer; z-index:20; }
    .modal__close:hover{ background:#2f2f2f; }

    .lock-panel{
      position:relative; width:100%; padding:16px; background:#0e1216;
      display:grid; place-items:center; min-height:60vh;
    }
    .lock-card{
      width:min(760px,92%); border-radius:20px; padding:12px; background:
        linear-gradient(180deg, #4b525b, #2f353d),
        repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.07), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.25), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow: 0 18px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 60px rgba(0,0,0,.25);
      outline: 1px solid rgba(255,255,255,.08);
    }
    .lock-card.unlocked{
      box-shadow: 0 18px 40px rgba(0,0,0,.5), 0 0 0 2px rgba(16,185,129,.28), inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 60px rgba(0,0,0,.25);
      filter: drop-shadow(0 0 24px rgba(16,185,129,.25));
    }
    .lock-card__inner{
      border-radius:16px; padding:16px; background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 80px rgba(0,0,0,.25);
    }

    .lock-dials{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:12px;
      width:100%;
    }
    .lock-dial{
      position:relative;
      height:clamp(110px, 20vw, 150px);
      border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.25));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.07), 0 6px 14px rgba(0,0,0,.45);
      overflow:hidden; user-select:none; touch-action:none;
      min-width:0;
    }
    .lock-dial::before, .lock-dial::after{
      content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
    }
    .lock-dial::before{
      background:
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.20), rgba(0,0,0,0) 60%);
      mix-blend-mode: screen; z-index: 1;
    }
    .lock-dial::after{
      background: linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,0) 28%, rgba(0,0,0,0) 72%, rgba(0,0,0,.35));
      z-index: 3;
    }

    .lock-reel{
      position:absolute; left:0; right:0; top:0; z-index:2; will-change: transform;
      background:
        linear-gradient(180deg, #767b84, #4e545c),
        repeating-linear-gradient(0deg, rgba(255,255,255,.06) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.18), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 30px rgba(0,0,0,.25);
    }
    .lock-cell{
      height:clamp(38px, 6.5vw, 52px);
      display:grid; place-items:center;
      font-weight:800; font-variant-numeric: tabular-nums;
      font-size: clamp(24px, 6.2vw, 34px);
      color:#0f141a;
      text-shadow: 0 1px 0 rgba(255,255,255,.35), 0 2px 2px rgba(0,0,0,.15);
      border-top: 1px dashed rgba(15,20,26,.22);
      border-bottom: 1px dashed rgba(15,20,26,.22);
    }
    .lock-centerline{
      position:absolute; left:8px; right:8px; top:50%; transform:translateY(-50%);
      height:0; border-top:1px dashed rgba(230,233,237,.45); z-index:4;
    }

    .lock-status{ margin-top:12px; text-align:center; font-size:.95rem; color:#e5e7eb; }
    .lock-status .ok{ color:var(--ok); font-weight:700; }
    .lock-status .no{ color:var(--err); font-weight:700; }
    .lock-actions{ margin-top:12px; text-align:center; }
    .lock-actions .btn{ min-width: 160px; }

    /* === CANVAS STORM GAME === */
    .storm-header{ padding:16px 16px 4px; background:#0c1116; border-bottom:1px solid rgba(255,255,255,.06); }
    .storm-topbar{ display:grid; grid-template-columns: 90px 1fr auto; align-items:center; gap:12px; margin-bottom:10px; }
    .storm-timer{ font-variant-numeric: tabular-nums; font-weight:800; color:#f5d76e; letter-spacing:.5px; }
    .storm-progress{ height:8px; background:#1b2430; border-radius:999px; overflow:hidden; }
    .storm-progress > span{ display:block; height:100%; width:100%; background:linear-gradient(90deg,#22c55e,#eab308); transform-origin:left; }

    .storm-game{
      position:relative; height:min(28vh, 240px); min-height:170px; border-radius:12px; overflow:hidden;
      background: radial-gradient(120% 100% at 50% 0%, rgba(12,17,22,.35), rgba(0,0,0,.7));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      isolation:isolate;
      touch-action:none; user-select:none;
    }
    .storm-canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .storm-overlay{
      position:absolute; inset:0; pointer-events:none; mix-blend-mode:screen; opacity:.55;
      background-image: repeating-linear-gradient(120deg, rgba(255,255,255,.07) 0 2px, rgba(255,255,255,0) 2px 12px);
      animation: rainShift 1.2s linear infinite;
    }
    @keyframes rainShift{ from{ background-position:0 0 } to{ background-position:-200px 300px } }

    .storm-msg{ margin-top:8px; color:#e5e7eb; font-size:.95rem; text-align:center; min-height:1.4em; }
    .storm-actions{ text-align:center; }
    .lives{ color:#e5e7eb; font-weight:700; font-variant-numeric: tabular-nums; }
    .shield{ color:#93c5fd; margin-left:8px; }

    .is-locked .lock-dials{ pointer-events:none; opacity:.6; filter: grayscale(.2); }
    .expired .lock-dials{ pointer-events:none; opacity:.4; }
  </style>
</head>
<body>
  <main class="wrap">
    <button id="btnReveal" class="btn btn--big" aria-controls="contentCard" aria-expanded="false">
      Affronta la tempesta!
    </button>

    <section class="card is-hidden" id="contentCard" aria-hidden="true" aria-labelledby="titolo-regole">
      <div class="card__head">
        <h2 id="titolo-regole" class="card__title">Affronta la tempesta!</h2>
        <div class="head__actions">
          <button id="btnMap" type="button" class="btn" aria-haspopup="dialog" aria-controls="modalMap">Codice</button>
          <button id="btnHide" type="button" class="btn btn--ghost" aria-controls="contentCard">Nascondi</button>
        </div>
      </div>

      <div class="riddle" id="riddleBox">
        <div class="riddle__scroller" id="riddleScroll">
Presto il codice o sarai affondato!
Ma ricorda bene tutto quello che hai passato.
Ti senti perso, non sai cosa pensare?
Guarda dove ti trovi e saprai cosa fare.
Non sempre la soluzione può essere dedotta,
in queste situazioni basta non perdere la rotta.
        </div>
        <div class="riddle__fade" aria-hidden="true"></div>
        <div class="riddle__indicator" aria-hidden="true"><i class="bi bi-caret-down-fill"></i></div>
      </div>
    </section>
  </main>

  <!-- Modale -->
  <div id="modalMap" class="modal" role="dialog" aria-modal="true" aria-label="Inserisci il codice" aria-hidden="true">
    <div class="modal__inner">
      <button class="modal__close" type="button" id="btnClose" aria-label="Chiudi (Esc)">Chiudi ✕</button>

      <!-- === CANVAS STORM GAME === -->
      <div id="stormHeader" class="storm-header">
        <div class="storm-topbar">
          <div id="stormTimer" class="storm-timer" aria-live="polite">02:00</div>
          <div class="storm-progress"><span id="stormProgressBar" style="width:100%"></span></div>
          <div class="storm-actions">
            <span id="stormLives" class="lives">❤️❤️❤️</span>
            <span id="stormShield" class="shield" style="display:none;">🛡️</span>
            <button id="stormRetry" class="btn btn--ghost" style="margin-left:8px; display:none;">Riprova</button>
          </div>
        </div>

        <div id="stormGame" class="storm-game" aria-label="Evita i fulmini e sopravvivi">
          <canvas id="stormCanvas" class="storm-canvas"></canvas>
          <div class="storm-overlay"></div>
        </div>

        <div id="stormMsg" class="storm-msg" aria-live="polite">Evita i fulmini telegraphati e sopravvivi per sbloccare i rulli.</div>
      </div>
      <!-- === FINE STORM GAME === -->

      <div class="lock-panel">
        <div id="lockCard" class="lock-card">
          <div class="lock-card__inner">
            <div id="lockDials" class="lock-dials">
              <div class="lock-dial" data-index="0"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="1"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="2"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="3"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="4"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="5"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
            </div>
            <div id="lockStatus" class="lock-status" aria-live="polite">Stato: <span class="no">Bloccato</span></div>
            <div class="lock-actions">
              <a id="btnNext" class="btn" href="luc58e.html" style="display:none;">Prosegui</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== Modale ===== */
    const btnMap   = document.getElementById('btnMap');
    const modal    = document.getElementById('modalMap');
    const btnClose = document.getElementById('btnClose');

    function openModal(){
      modal.classList.add('open');
      modal.setAttribute('aria-hidden','false');
      btnClose && btnClose.focus();
      initLockOnce();
    }
    function closeModal(){
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden','true');
      btnMap && btnMap.focus();
    }
    btnMap.addEventListener('click', openModal);
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
    window.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.classList.contains('open')) closeModal(); });

    /* ===== Overlay scroll (card) ===== */
    const riddleBox = document.getElementById('riddleBox');
    const scroller  = document.getElementById('riddleScroll');
    function updateOverlay(){
      const canScroll = scroller.scrollHeight > scroller.clientHeight + 1;
      riddleBox.classList.toggle('--no-scroll', !canScroll);
      const atBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 1;
      riddleBox.classList.toggle('--at-bottom', atBottom);
    }
    scroller.addEventListener('scroll', updateOverlay);
    window.addEventListener('load', () => { requestAnimationFrame(updateOverlay); });
    window.addEventListener('resize', () => { requestAnimationFrame(updateOverlay); });

    /* ===== Reveal/Hide card ===== */
    (function(){
      const REVEAL_KEY = 'card_revealed_v1::' + location.pathname;
      const btnReveal = document.getElementById('btnReveal');
      const card = document.getElementById('contentCard');
      const btnHide = document.getElementById('btnHide');
      const title = document.getElementById('titolo-regole');

      function reveal(){
        card.classList.remove('is-hidden');
        card.setAttribute('aria-hidden','false');
        btnReveal.setAttribute('aria-expanded','true');
        btnReveal.style.display = 'none';
        btnHide.style.display = '';
        try{ localStorage.setItem(REVEAL_KEY, '1'); }catch{}
        if(title){ title.setAttribute('tabindex','-1'); title.focus(); }
      }
      function hide(){
        card.classList.add('is-hidden');
        card.setAttribute('aria-hidden','true');
        btnReveal.setAttribute('aria-expanded','false');
        btnReveal.style.display = 'block';
        btnHide.style.display = 'none';
        try{ localStorage.removeItem(REVEAL_KEY); }catch{}
        btnReveal.focus();
      }
      function init(){
        const wasRevealed = (()=>{ try{ return localStorage.getItem(REVEAL_KEY)==='1'; }catch{ return false; }})();
        if(wasRevealed){
          card.classList.remove('is-hidden');
          card.setAttribute('aria-hidden','false');
          btnReveal.style.display = 'none';
          btnReveal.setAttribute('aria-expanded','true');
          btnHide.style.display = '';
        }else{
          card.classList.add('is-hidden');
          card.setAttribute('aria-hidden','true');
          btnReveal.style.display = 'block';
          btnReveal.setAttribute('aria-expanded','false');
          btnHide.style.display = 'none';
        }
        btnReveal.addEventListener('click', reveal);
        btnReveal.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); reveal(); } });
        btnHide.addEventListener('click', hide);
      }
      init();
    })();

    /* ======== Lucchetto ======== */
    const LOCK_H = (() => ['YfAr','gnE9','eUom','egxQ','F9uL','pudk','E2rA','63WW','/W1U','ksHf','dlQ='].join(''))();
    const LOCK_P = (() => ['GAL','LEON','-','14','92','-','RO','GER'].join(''))();
    const LOCK_S = (() => ['BLA','CK','PE','AR','L'].join(''))();

    const lockCard   = document.getElementById('lockCard');
    const lockStatus = document.getElementById('lockStatus');
    const btnNext    = document.getElementById('btnNext');
    const dialEls    = [];
    let lockInited   = false;

    let values = Array(6).fill(0);
    let CELL_H = 50;
    let verifySeq = 0;

    function initLockOnce(){
      if(lockInited){
        measureCellHeight();
        positionAllToCurrent();
        queueVerify();
        return;
      }
      const container = document.getElementById('lockDials');
      const dials = [...container.querySelectorAll('.lock-dial')];
      dials.forEach(d => dialEls.push(d));

      const baseDigits = Array.from({length:10}, (_,i)=>i);
      const loopDigits = [...baseDigits, ...baseDigits, ...baseDigits];
      dialEls.forEach(dial => {
        const reel = dial.querySelector('.lock-reel');
        reel.innerHTML = loopDigits.map(d => `<div class="lock-cell">${d}</div>`).join('');
      });

      measureCellHeight();
      values = Array(6).fill(0);
      dialEls.forEach((_, idx) => positionReelAtValue(idx, 0));

      dialEls.forEach((dial, idx) => {
        const reel = dial.querySelector('.lock-reel');
        let startY=0, startOffset=0, lastY=0, lastTime=0, velocity=0, dragging=false;

        dial.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          dial.setPointerCapture(e.pointerId);
          dragging = true;
          startY = e.clientY;
          startOffset = Number(reel.dataset.offset || 0);
          lastY = startY; lastTime = performance.now(); velocity = 0;
        });
        dial.addEventListener('pointermove', (e) => {
          if(!dragging) return;
          const y = e.clientY;
          const dy = y - startY;
          const next = startOffset + dy;
          setReelOffset(idx, next);
          const now = performance.now(), dt = now - lastTime;
          if(dt>0) velocity = (y - lastY) / dt;
          lastY = y; lastTime = now;
        });
        dial.addEventListener('pointerup', () => {
          if(!dragging) return; dragging = false;
          const inertial = clamp(velocity, -0.9, 0.9) * CELL_H * 2;
          snapToNearest(idx, Number(reel.dataset.offset || 0) + inertial);
        });
        dial.addEventListener('pointercancel', () => {
          if(!dragging) return; dragging = false;
          snapToNearest(idx, Number(reel.dataset.offset || 0));
        });
        dial.addEventListener('wheel', (e) => { e.preventDefault(); nudge(idx, Math.sign(e.deltaY)); }, {passive:false});
        dial.tabIndex = 0;
        dial.addEventListener('keydown', (e) => {
          if(e.key==='ArrowUp'){ e.preventDefault(); nudge(idx,-1); }
          if(e.key==='ArrowDown'){ e.preventDefault(); nudge(idx,+1); }
          if(e.key==='Home'){ e.preventDefault(); setValue(idx,0,true); }
          if(e.key==='End'){  e.preventDefault(); setValue(idx,9,true); }
        });
      });

      queueVerify();
      lockInited = true;

      window.addEventListener('resize', () => {
        if(!modal.classList.contains('open')) return;
        measureCellHeight(); positionAllToCurrent(); queueVerify();
      });

      btnNext.addEventListener('click', (e) => {
        if(!btnNext.href) return;
        e.preventDefault();
        closeModal();
        setTimeout(()=>{ window.location.href = btnNext.href; }, 220);
      });
    }

    function measureCellHeight(){
      const any = document.querySelector('.lock-cell');
      if(any) CELL_H = any.getBoundingClientRect().height || 50;
    }
    function positionAllToCurrent(){ dialEls.forEach((_, i)=>positionReelAtValue(i, values[i] || 0)); }
    function positionReelAtValue(dialIndex, value){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const targetIndex = 10 + value;
      const translateY = -targetIndex * CELL_H + dial.getBoundingClientRect().height/2 - CELL_H/2;
      reel.style.transform = `translateY(${translateY}px)`;
      reel.dataset.offset = translateY;
      values[dialIndex] = value;
    }
    function setReelOffset(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      reel.style.transform = `translateY(${offset}px)`;
      reel.dataset.offset = offset;
    }
    function nudge(dialIndex, delta){
      const nextVal = mod(values[dialIndex] + delta, 10);
      setValue(dialIndex, nextVal, true);
    }
    function setValue(dialIndex, value, animate=true){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      if(animate){
        reel.style.transition = 'transform .12s ease-out';
        requestAnimationFrame(() => {
          setReelOffset(dialIndex, targetOffset);
          setTimeout(() => { reel.style.transition = ''; }, 140);
        });
      } else {
        setReelOffset(dialIndex, targetOffset);
      }
      values[dialIndex] = value;
      queueVerify();
    }
    function snapToNearest(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const rawIndex = -(offset - centerY) / CELL_H;

      const value = mod(Math.round(rawIndex), 10);
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      reel.style.transition = 'transform .12s ease-out';
      requestAnimationFrame(() => {
        setReelOffset(dialIndex, targetOffset);
        setTimeout(() => { reel.style.transition = ''; }, 140);
      });
      values[dialIndex] = value;
      queueVerify();
    }

    async function sha256Base64(str){
      const enc = new TextEncoder();
      const data = enc.encode(str);
      const buf  = await crypto.subtle.digest('SHA-256', data);
      const bytes = new Uint8Array(buf);
      let binary = ''; for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function safeEqual(a,b){
      if (a.length !== b.length) return false;
      let r = 0; for (let i=0; i<a.length; i++) r |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return r === 0;
    }
    function queueVerify(){
      const seq = ++verifySeq;
      verifyCurrentCode().then(ok => {
        if(seq !== verifySeq) return;
        lockCard.classList.toggle('unlocked', ok);
        lockStatus.innerHTML = ok ? 'Stato: <span class="ok">Sbloccato</span>' : 'Stato: <span class="no">Bloccato</span>';
        btnNext.style.display = ok ? 'inline-block' : 'none';
      });
    }
    async function verifyCurrentCode(){
      const code = values.join('');
      const msg  = LOCK_P + '|' + code + '|' + LOCK_S;
      const digestB64 = await sha256Base64(msg);
      return safeEqual(digestB64, LOCK_H);
    }

    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function mod(n,m){ return ((n % m) + m) % m; }

    /* ==================== CANVAS STORM GAME (accattivante & sfidante) ==================== */
    const stormTimerEl = document.getElementById('stormTimer');
    const stormProgressBar = document.getElementById('stormProgressBar');
    const stormMsgEl = document.getElementById('stormMsg');
    const stormGameEl = document.getElementById('stormGame');
    const canvas = document.getElementById('stormCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const stormRetryBtn = document.getElementById('stormRetry');
    const stormLivesEl = document.getElementById('stormLives');
    const stormShieldEl = document.getElementById('stormShield');

    const ST_KEY = 'storm_state_v3::' + location.pathname;

    // Parametri
    const COUNTDOWN_MS = 2 * 60 * 1000;
    const REQUIRED_SURVIVE_MS = 15 * 1000;
    const MAX_LIVES = 3;
    const BASE_SPAWN_EVERY = [650, 1100];
    const BASE_FALL_SPEED = [260, 400];
    const ZIGZAG_AMPL = 40;
    const ZIGZAG_FREQ = 6;
    const TELEGRAPH_TIME = [380, 700];
    const WIND_CHANGE_EVERY = 2000;
    const WIND_MAX = 60;         // px/s di deriva massima
    const SHIP_ACCEL = 900;      // px/s^2
    const SHIP_FRICTION = 0.88;  // damping
    const SHIP_MAX_V = 480;      // px/s
    const SHIP_Y = 0.82;         // posizione verticale come % altezza
    const SHIELD_PROB = 0.12;    // probabilità di spawn scudo
    const SHIELD_DURATION = 8000;

    // Stato runtime
    let st = null; // { deadline, won, surviveMs, lives, shieldUntil }
    let rafId = null, lastRealTs = 0, lastLoop = 0;
    let w=0, h=0, dpr=1;

    // Nave
    const ship = { x: 0.5, vx: 0 }; // x normalizzata [0..1]
    let inputLeft = false, inputRight = false;

    // Vento
    let wind = 0; // px/s
    let windTimer = 0;

    // Fulmini
    const bolts = []; // { kind:'down'|'zigzag'|'tracking', x, y, vx, vy, teleUntil, width, hitbox, targetX }
    let spawnTimer = 0, nextSpawnIn = 800;

    // Shield (power-up)
    let shieldOrb = null; // {x,y,vy,expires}
    function hasShield(){ return st.shieldUntil && st.shieldUntil > performance.now(); }

    function loadState(){
      try{ const raw = localStorage.getItem(ST_KEY); if(raw) return JSON.parse(raw); }catch{}
      return { deadline: 0, won:false, surviveMs:0, lives:MAX_LIVES, shieldUntil:0 };
    }
    function saveState(){ try{ localStorage.setItem(ST_KEY, JSON.stringify(st)); }catch{} }

    function msToMMSS(ms){
      const t = Math.max(0, Math.ceil(ms/1000));
      const m = String(Math.floor(t/60)).padStart(2,'0');
      const s = String(t%60).padStart(2,'0');
      return `${m}:${s}`;
    }
    function updateTimerUI(){
      const now = Date.now();
      const total = COUNTDOWN_MS;
      const left = Math.max(0, st.deadline - now);
      stormTimerEl.textContent = msToMMSS(left);
      stormProgressBar.style.transform = `scaleX(${left/total})`;
      return left;
    }
    function setLives(n){
      const L = clamp(n, 0, MAX_LIVES);
      st.lives = L;
      stormLivesEl.textContent = '❤️'.repeat(L) + '🖤'.repeat(MAX_LIVES-L);
      if(L<=0){
        stormMsgEl.textContent = 'La tempesta ti ha colpito! Riprova.';
        setExpiredUI(true);
      }
    }
    function setShieldUI(){
      stormShieldEl.style.display = hasShield() ? 'inline' : 'none';
    }
    function lockDials(locked){ lockCard.classList.toggle('is-locked', locked); }
    function setExpiredUI(expired){
      lockCard.classList.toggle('expired', expired);
      stormRetryBtn.style.display = expired ? 'inline-block' : 'none';
    }

    function resizeCanvas(){
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = stormGameEl.getBoundingClientRect();
      w = Math.max(300, Math.floor(rect.width));
      h = Math.max(160, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w+'px';
      canvas.style.height = h+'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function resetChallenge(){
      st = { deadline: Date.now() + COUNTDOWN_MS, won:false, surviveMs:0, lives:MAX_LIVES, shieldUntil:0 };
      saveState();
      lockDials(true);
      setExpiredUI(false);
      stormMsgEl.textContent = 'Evita i fulmini e sopravvivi per sbloccare i rulli.';
      ship.x = 0.5; ship.vx = 0;
      wind = 0; windTimer = 0;
      bolts.length = 0;
      shieldOrb = null;
      spawnTimer = 0; nextSpawnIn = rand(BASE_SPAWN_EVERY[0], BASE_SPAWN_EVERY[1]);
      lastRealTs = 0; lastLoop = 0;
      setLives(MAX_LIVES);
      setShieldUI();
      resizeCanvas();
      ensureLoop();
      updateTimerUI();
    }

    /* --- Helpers --- */
    function rand(a,b){ return a + Math.random()*(b-a); }
    function lerp(a,b,t){ return a+(b-a)*t; }
    function easeOutExpo(t){ return 1 - Math.pow(2, -8*t); }

    /* --- Spawn --- */
    function spawnBolt(){
      const elapsed = st.surviveMs;
      // Difficoltà crescente: più tempo -> più veloci e spawn più frequenti
      const diff = clamp(elapsed/15000, 0, 1); // 0..1 entro 15s
      const fallMin = BASE_FALL_SPEED[0] + 80*diff;
      const fallMax = BASE_FALL_SPEED[1] + 100*diff;

      const kindPick = Math.random();
      let kind = 'down';
      if(kindPick > 0.65) kind = 'zigzag';
      if(kindPick > 0.85) kind = 'tracking';

      const bw = rand(10, 20) * (1+0.3*diff);

      const teleMs = rand(TELEGRAPH_TIME[0], TELEGRAPH_TIME[1]);
      let x = Math.random()*w;
      let targetX = x;
      if(kind==='tracking'){ targetX = ship.x * w + rand(-30, 30); x = clamp(targetX + rand(-120,120), 12, w-12); }

      bolts.push({
        kind,
        x, y: -140,
        vx: kind==='zigzag' ? rand(-40, 40) : 0,
        vy: rand(fallMin, fallMax),
        teleUntil: performance.now() + teleMs,
        width: bw,
        spawnAt: performance.now(),
        targetX
      });
    }
    function maybeSpawnShield(){
      if(shieldOrb || Math.random() > SHIELD_PROB) return;
      shieldOrb = { x: Math.random()*w, y: -20, vy: 80, expires: performance.now()+12000 };
    }

    /* --- Disegno --- */
    function drawBackground(t){
      // Onde scure + bagliori lontani
      ctx.save();
      ctx.fillStyle = '#0b1220';
      ctx.fillRect(0,0,w,h);

      // mare
      for(let i=0;i<4;i++){
        const y = h*0.65 + i*12;
        ctx.globalAlpha = 0.08 + i*0.04;
        ctx.fillStyle = '#1f2937';
        ctx.beginPath();
        ctx.moveTo(0,y);
        for(let x=0;x<=w; x+=8){
          const off = Math.sin((x*0.02)+(t*0.001*(0.6+i*0.2)))*4*(1+i*0.4);
          ctx.lineTo(x, y + off);
        }
        ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }
    function drawShip(t){
      const sx = ship.x * w;
      const sy = h*SHIP_Y;

      // scia
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#1e3a8a';
      ctx.beginPath();
      ctx.ellipse(sx, sy+18, 24, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // scafo stilizzato
      ctx.save();
      ctx.translate(sx, sy);
      const tilt = clamp(ship.vx/SHIP_MAX_V, -0.6, 0.6);
      ctx.rotate(tilt*0.08);
      // scafo
      const grd = ctx.createLinearGradient(0,-12,0,16);
      grd.addColorStop(0,'#a16207'); grd.addColorStop(1,'#7c3e0a');
      ctx.fillStyle = grd;
      ctx.strokeStyle = '#3b2c20';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-18,8); ctx.lineTo(18,8); ctx.lineTo(12,18); ctx.lineTo(-12,18); ctx.closePath();
      ctx.fill(); ctx.stroke();
      // albero
      ctx.fillStyle = '#3b2c20';
      ctx.fillRect(-1.5,-18,3,26);
      // vele
      const sail = ctx.createLinearGradient(-20,0,20,0);
      sail.addColorStop(0,'#f8fafc'); sail.addColorStop(1,'#e2e8f0');
      ctx.fillStyle = sail; ctx.strokeStyle = '#a1a1aa'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(0,6); ctx.lineTo(-16,0); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(0,6); ctx.lineTo(16,-2); ctx.closePath(); ctx.fill(); ctx.stroke();

      // scudo attivo
      if(hasShield()){
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = '#60a5fa';
        ctx.beginPath(); ctx.arc(0,0,26,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }
    function drawTelegraph(b, now){
      const tLeft = b.teleUntil - now;
      if(tLeft <= 0) return;
      const alpha = 0.35 + 0.25*Math.sin((now-b.spawnAt)/80);
      ctx.save();
      if(b.kind==='zigzag'){
        ctx.strokeStyle = `rgba(147,197,253,${alpha})`;
        ctx.lineWidth = b.width*0.7;
        ctx.setLineDash([12, 12]);
        ctx.beginPath();
        ctx.moveTo(b.x, 0);
        ctx.lineTo(b.x + 60, h*0.35);
        ctx.lineTo(b.x - 40, h*0.7);
        ctx.lineTo(b.x + 20, h);
        ctx.stroke();
      }else{
        const tx = b.kind==='tracking' ? b.targetX : b.x;
        const grad = ctx.createLinearGradient(tx,0,tx,h);
        grad.addColorStop(0, `rgba(250,250,210,${alpha})`);
        grad.addColorStop(1, `rgba(250,250,210,0)`);
        ctx.fillStyle = grad;
        ctx.fillRect(tx - b.width*0.8, 0, b.width*1.6, h);
      }
      ctx.restore();
    }
    function drawBolt(b){
      ctx.save();
      ctx.shadowColor = 'rgba(255,255,200,.7)';
      ctx.shadowBlur = 16;
      ctx.strokeStyle = '#fde68a';
      ctx.lineWidth = b.width;
      ctx.lineCap = 'round';
      ctx.beginPath();
      if(b.kind==='zigzag'){
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + 60, b.y + 120);
        ctx.moveTo(b.x + 60, b.y + 120);
        ctx.lineTo(b.x - 40, b.y + 220);
        ctx.moveTo(b.x - 40, b.y + 220);
        ctx.lineTo(b.x + 20, b.y + 320);
      }else{
        const tx = b.kind==='tracking' ? b.targetX : b.x;
        ctx.moveTo(tx, b.y);
        ctx.lineTo(tx, b.y + 160);
      }
      ctx.stroke();
      // bagliore
      const g = ctx.createRadialGradient(b.x, b.y+80, 0, b.x, b.y+80, 160);
      g.addColorStop(0,'rgba(255,255,210,.22)');
      g.addColorStop(1,'rgba(255,255,210,0)');
      ctx.fillStyle = g;
      ctx.fillRect(b.x-200, b.y-20, 400, 300);
      ctx.restore();
    }
    function drawShieldOrb(){
      if(!shieldOrb) return;
      ctx.save();
      ctx.shadowColor = '#93c5fd';
      ctx.shadowBlur = 18;
      ctx.fillStyle = 'rgba(147,197,253,.85)';
      ctx.beginPath();
      ctx.arc(shieldOrb.x, shieldOrb.y, 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    /* --- Collisioni --- */
    function shipBounds(){
      const sx = ship.x * w;
      const sy = h*SHIP_Y;
      return { x:sx-14, y:sy-10, w:28, h:24 };
    }
    function rectsOverlap(a,b){
      return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
    }

    /* --- Input --- */
    function onPointer(e){
      const rect = canvas.getBoundingClientRect();
      const xNorm = clamp((e.clientX - rect.left) / rect.width, 0, 1);
      // imposta direzione verso il punto
      const targetX = xNorm * w;
      const dx = targetX - ship.x*w;
      ship.vx += clamp(dx*6, -SHIP_MAX_V, SHIP_MAX_V);
    }
    stormGameEl.addEventListener('pointerdown', (e)=>{ stormGameEl.setPointerCapture(e.pointerId); onPointer(e); });
    stormGameEl.addEventListener('pointermove', (e)=>{ if(e.pressure!==0 || e.buttons>0) onPointer(e); });
    window.addEventListener('keydown', (e)=>{
      if(!modal.classList.contains('open')) return;
      if(e.key==='ArrowLeft' || e.key==='a') inputLeft = true;
      if(e.key==='ArrowRight'|| e.key==='d') inputRight = true;
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key==='ArrowLeft' || e.key==='a') inputLeft = false;
      if(e.key==='ArrowRight'|| e.key==='d') inputRight = false;
    });

    /* --- Loop --- */
    function ensureLoop(){ if(!rafId) rafId = requestAnimationFrame(loop); }
    function stopLoop(){ if(rafId){ cancelAnimationFrame(rafId); rafId=null; } lastRealTs=0; lastLoop=0; }

    function loop(ts){
      if(!modal.classList.contains('open')){ stopLoop(); return; }
      if(!lastRealTs){ lastRealTs = ts; lastLoop = ts; }
      const dt = Math.min(100, ts - lastLoop); // ms
      lastLoop = ts;
      const dtSec = dt/1000;

      // Timer gameplay e UI
      const left = updateTimerUI();
      if(left<=0){ setExpiredUI(true); lockDials(true); stopLoop(); return; }
      if(st.lives<=0){ saveState(); return; } // morto, aspetta retry
      if(st.won){ saveState(); rafId = requestAnimationFrame(loop); return; }

      // Canvas
      ctx.clearRect(0,0,w,h);
      drawBackground(ts);

      // Vento/deriva
      windTimer += dt;
      if(windTimer >= WIND_CHANGE_EVERY){
        windTimer = 0;
        const target = rand(-WIND_MAX, WIND_MAX);
        // avvicina lentamente al nuovo vento
        wind = lerp(wind, target, 0.9);
      }

      // Input → accelerazione
      let ax = 0;
      if(inputLeft) ax -= SHIP_ACCEL;
      if(inputRight) ax += SHIP_ACCEL;

      // Fisica nave
      ship.vx += (ax + wind) * dtSec;
      ship.vx = clamp(ship.vx, -SHIP_MAX_V, SHIP_MAX_V);
      ship.vx *= Math.pow(SHIP_FRICTION, dtSec*60);
      ship.x += (ship.vx * dtSec) / w;
      ship.x = clamp(ship.x, 0.04, 0.96);
      drawShip(ts);

      // Spawn scudo casuale
      if(Math.random()<0.004) maybeSpawnShield();

      // Shield orb
      if(shieldOrb){
        shieldOrb.y += shieldOrb.vy*dtSec;
        drawShieldOrb();
        if(performance.now()>shieldOrb.expires || shieldOrb.y>h+20) shieldOrb=null;
        else{
          const s = shipBounds();
          const orbRect = { x: shieldOrb.x-10, y: shieldOrb.y-10, w:20, h:20 };
          if(rectsOverlap(s, orbRect)){
            st.shieldUntil = performance.now()+SHIELD_DURATION;
            shieldOrb=null; setShieldUI();
            stormMsgEl.textContent = 'Scudo attivo per 8s!';
          }
        }
      }

      // Spawn fulmini dinamico con difficoltà
      spawnTimer += dt;
      const diff = clamp(st.surviveMs/15000, 0, 1);
      const spawnEvery = lerp(BASE_SPAWN_EVERY[1], BASE_SPAWN_EVERY[0], diff);
      if(spawnTimer >= spawnEvery){
        spawnTimer = 0; nextSpawnIn = spawnEvery;
        spawnBolt();
      }

      // Disegna telegraph
      const now = performance.now();
      for(const b of bolts) drawTelegraph(b, now);

      // Aggiorna & disegna fulmini
      const removeIdx = [];
      for(let i=0;i<bolts.length;i++){
        const b = bolts[i];
        if(now < b.teleUntil){
          // tracking aggiorna target durante telegraph (se kind tracking)
          if(b.kind==='tracking'){ b.targetX = lerp(b.targetX, ship.x*w, 0.08); }
          continue;
        }
        // caduta
        b.y += b.vy*dtSec;
        if(b.kind==='zigzag'){
          b.x += Math.sin((now - b.spawnAt)/100) * (ZIGZAG_AMPL*dtSec);
        }else if(b.kind==='down'){
          // nulla
        }else if(b.kind==='tracking'){
          // leggera correzione in discesa
          b.x = lerp(b.x, b.targetX, 0.04);
        }
        drawBolt(b);

        // collisione
        const s = shipBounds();
        const boltRect = { x:(b.kind==='tracking'? (b.targetX - b.width*0.6) : (b.x - b.width*0.6)),
                           y:b.y, w:b.width*1.2, h: (b.kind==='zigzag'? 300 : 160) };
        if(rectsOverlap(s, boltRect)){
          if(hasShield()){
            st.shieldUntil = 0; setShieldUI();
            // piccolo flash
            ctx.save(); ctx.globalAlpha = .25; ctx.fillStyle='#93c5fd'; ctx.fillRect(0,0,w,h); ctx.restore();
          }else{
            setLives(st.lives - 1);
            // flash giallo
            ctx.save(); ctx.globalAlpha = .18; ctx.fillStyle='#fde68a'; ctx.fillRect(0,0,w,h); ctx.restore();
          }
          removeIdx.push(i);
        }else if(b.y > h+200){
          removeIdx.push(i);
        }
      }
      // rimozione
      for(let i=removeIdx.length-1;i>=0;i--) bolts.splice(removeIdx[i],1);

      // Sopravvivenza cumulativa
      st.surviveMs += dt;
      if(st.surviveMs >= REQUIRED_SURVIVE_MS){
        st.won = true;
        stormMsgEl.textContent = 'Tempesta superata! Ora puoi inserire la combinazione.';
        lockDials(false);
      }else{
        const remain = Math.max(0, REQUIRED_SURVIVE_MS - st.surviveMs);
        stormMsgEl.textContent = `Resisti ancora ${(remain/1000).toFixed(1)}s…`;
      }

      saveState();
      rafId = requestAnimationFrame(loop);
    }

    function setExpiredUI(expired){
      lockCard.classList.toggle('expired', expired);
      stormRetryBtn.style.display = expired ? 'inline-block' : 'none';
      if(expired) stormMsgEl.textContent = 'Tempo o vite finite. Riprova!';
    }

    // Retry
    stormRetryBtn.addEventListener('click', ()=>{
      resetChallenge();
      ensureLoop();
    });

    // Boot del gioco all'apertura modale
    btnMap.addEventListener('click', ()=>{
      setTimeout(()=>{
        resizeCanvas();
        st = loadState();
        if(!st.deadline || st.deadline <= Date.now()){
          resetChallenge();
        }else{
          updateTimerUI();
          lockDials(!st.won);
          setLives(st.lives ?? MAX_LIVES);
          setShieldUI();
          stormMsgEl.textContent = st.won ? 'Tempesta superata! Ora puoi inserire la combinazione.' : 'Evita i fulmini e sopravvivi per sbloccare i rulli.';
          ensureLoop();
        }
      },0);
    });

    window.addEventListener('resize', ()=>{
      if(modal.classList.contains('open')){ resizeCanvas(); ensureLoop(); }
    });
  </script>
</body>
</html>
