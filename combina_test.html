<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Forziere a combinazione — rulli trascinabili (acciaio, SHA)</title>
  <style>
    :root{ --ok:#10b981; --err:#ef4444; }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{
      height:100%; margin:0; background:#0d0f12; color:#e5e7eb;
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      overscroll-behavior: none;
    }
    body{ display:grid; place-items:center; overflow:hidden; }

    /* sfondo scuro con vignetta */
    body::before{
      content:""; position:fixed; inset:0; z-index:-2;
      background:
        radial-gradient(ellipse at 50% 20%, rgba(0,0,0,.35), rgba(0,0,0,.8) 70%),
        linear-gradient(90deg, #0c0f14, #0b0d11);
    }

    .wrap{ width:min(920px,100vw); padding:16px; }

    /* contenitore generale */
    .chest{
      position:relative; width:100%; aspect-ratio:16/9;
      border-radius:18px;
      box-shadow: 0 20px 40px rgba(0,0,0,.55), inset 0 0 0 2px rgba(255,255,255,.03);
      display:grid; place-items:center; padding:clamp(8px,2vw,22px);
      background:
        radial-gradient(120% 100% at 50% 50%, rgba(255,255,255,.05), rgba(255,255,255,0) 60%),
        linear-gradient(180deg, #1a1f26, #101419);
      transition: transform .2s ease, filter .25s ease;
    }
    .chest.unlocked{
      box-shadow:
        0 24px 50px rgba(0,0,0,.6),
        0 0 0 2px rgba(16,185,129,.28),
        inset 0 0 0 2px rgba(255,255,255,.05);
      filter: drop-shadow(0 0 24px rgba(16,185,129,.3));
    }

    /* card acciaio più scuro dei rulli */
    .panel{
      position:relative; z-index:1; width:min(720px,96%);
      border-radius:20px; padding:12px;
      background:
        linear-gradient(180deg, #4b525b, #2f353d), /* base acciaio scuro */
        repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.07), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.25), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow:
        0 18px 40px rgba(0,0,0,.5),
        inset 0 0 0 1px rgba(255,255,255,.06),
        inset 0 0 60px rgba(0,0,0,.25);
      outline: 1px solid rgba(255,255,255,.08);
    }
    .panel__inner{
      border-radius:16px;
      padding:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.06),
        inset 0 0 80px rgba(0,0,0,.25);
    }

    .dials{ display:grid; grid-template-columns:repeat(6,1fr); gap:12px; }

    /* rullo singolo con cornice acciaio */
    .dial{
      position:relative;
      height:clamp(124px, 24vw, 164px);
      border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.25));
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.07),
        0 6px 14px rgba(0,0,0,.45);
      overflow:hidden;
      user-select:none;
      touch-action:none; /* drag verticale senza scroll */
    }
    .dial::before, .dial::after{
      content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
    }
    .dial::before{
      background:
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.20), rgba(0,0,0,0) 60%);
      mix-blend-mode: screen; z-index: 1;
    }
    .dial::after{
      background:
        linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,0) 28%, rgba(0,0,0,0) 72%, rgba(0,0,0,.35));
      z-index: 3;
    }

    /* >>> tamburo numeri (acciaio chiaro) <<< */
    .reel{
      position:absolute; left:0; right:0; top:0; z-index:2;
      will-change: transform;
      background:
        linear-gradient(180deg, #767b84, #4e545c), /* base acciaio (più chiaro dei bordi) */
        repeating-linear-gradient(0deg, rgba(255,255,255,.06) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.18), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 30px rgba(0,0,0,.25);
    }

    .cell{
      height:clamp(42px, 8vw, 56px);
      display:grid; place-items:center;
      font-weight:800; font-variant-numeric: tabular-nums;
      font-size: clamp(28px, 7vw, 36px);
      color:#0f141a;
      text-shadow: 0 1px 0 rgba(255,255,255,.35), 0 2px 2px rgba(0,0,0,.15);
      border-top: 1px dashed rgba(15,20,26,.22);
      border-bottom: 1px dashed rgba(15,20,26,.22);
    }

    .center-line{
      position:absolute; left:8px; right:8px; top:50%; transform:translateY(-50%);
      height:0; border-top:1px dashed rgba(230,233,237,.45); z-index:4;
    }

    .status{ margin-top:12px; text-align:center; font-size:.95rem; color:#e5e7eb; }
    .status .ok{ color:var(--ok); font-weight:700; }
    .status .no{ color:var(--err); font-weight:700; }

    @media (max-width: 420px){ .dials{ grid-template-columns: repeat(3, 1fr); } }
    @media (prefers-reduced-motion: reduce){ *{ transition:none !important; animation:none !important; } }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="chest" id="chest">
      <div class="panel" role="group" aria-label="Lucchetto a combinazione">
        <div class="panel__inner">
          <div class="dials" id="dials">
            <div class="dial" data-index="0" aria-label="Cifra 1"><div class="reel"></div><div class="center-line"></div></div>
            <div class="dial" data-index="1" aria-label="Cifra 2"><div class="reel"></div><div class="center-line"></div></div>
            <div class="dial" data-index="2" aria-label="Cifra 3"><div class="reel"></div><div class="center-line"></div></div>
            <div class="dial" data-index="3" aria-label="Cifra 4"><div class="reel"></div><div class="center-line"></div></div>
            <div class="dial" data-index="4" aria-label="Cifra 5"><div class="reel"></div><div class="center-line"></div></div>
            <div class="dial" data-index="5" aria-label="Cifra 6"><div class="reel"></div><div class="center-line"></div></div>
          </div>

          <div class="status" id="status" aria-live="polite">
            Stato: <span class="no">Bloccato</span>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===============================
    //  Config "segreta" (derivata)
    // ===============================
    // Hash target (SHA-256 base64) spezzato:
    const H = (() => [
      'YfAr','gnE9','eUom','egxQ','F9uL','pudk','E2rA','63WW','/W1U','ksHf','dlQ='
    ].join(''))();

    // Pepper e "sig" ricostruiti a runtime (non in chiaro in un'unica costante):
    const P = (() => ['GAL','LEON','-','14','92','-','RO','GER'].join(''))(); // "GALLEON-1492-ROGER"
    const S = (() => ['BLA','CK','PE','AR','L'].join(''))();                // "BLACKPEARL"

    // ===============================
    //  UI: rulli trascinabili
    // ===============================
    const chest   = document.getElementById('chest');
    const statusEl= document.getElementById('status');
    const dialEls = [...document.querySelectorAll('.dial')];

    const values = Array(6).fill(0);
    const baseDigits = Array.from({length:10}, (_,i)=>i);
    const loopDigits = [...baseDigits, ...baseDigits, ...baseDigits]; // 30 celle

    dialEls.forEach(dial => {
      const reel = dial.querySelector('.reel');
      reel.innerHTML = loopDigits.map(d => `<div class="cell">${d}</div>`).join('');
    });

    let CELL_H = 50;
    function measureCellHeight(){
      const anyCell = document.querySelector('.cell');
      if(anyCell) CELL_H = anyCell.getBoundingClientRect().height;
    }
    measureCellHeight();
    addEventListener('resize', measureCellHeight, {passive:true});

    function positionReelAtValue(dialIndex, value){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.reel');
      const targetIndex = 10 + value; // fascia centrale (10..19)
      const translateY = -targetIndex * CELL_H + dial.getBoundingClientRect().height/2 - CELL_H/2;
      reel.style.transform = `translateY(${translateY}px)`;
      reel.dataset.offset = translateY;
      values[dialIndex] = value;
    }
    dialEls.forEach((_, idx) => positionReelAtValue(idx, 0));

    // Interazione
    dialEls.forEach((dial, idx) => {
      const reel = dial.querySelector('.reel');

      let startY = 0, startOffset = 0, lastY = 0, lastTime = 0, velocity = 0, dragging = false;

      dial.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        dial.setPointerCapture(e.pointerId);
        dragging = true;
        startY = e.clientY;
        startOffset = Number(reel.dataset.offset || 0);
        lastY = startY;
        lastTime = performance.now();
        velocity = 0;
      });
      dial.addEventListener('pointermove', (e) => {
        if(!dragging) return;
        const y = e.clientY;
        const dy = y - startY;
        const next = startOffset + dy;
        setReelOffset(idx, next);

        const now = performance.now();
        const dt = now - lastTime;
        if(dt > 0) velocity = (y - lastY) / dt;
        lastY = y; lastTime = now;
      });
      dial.addEventListener('pointerup', () => {
        if(!dragging) return;
        dragging = false;
        const inertial = clamp(velocity, -0.9, 0.9) * CELL_H * 2;
        snapToNearest(idx, Number(reel.dataset.offset || 0) + inertial);
      });
      dial.addEventListener('pointercancel', () => {
        if(!dragging) return;
        dragging = false;
        snapToNearest(idx, Number(reel.dataset.offset || 0));
      });

      dial.addEventListener('wheel', (e) => {
        e.preventDefault();
        nudge(idx, Math.sign(e.deltaY));
      }, {passive:false});

      dial.tabIndex = 0;
      dial.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowUp'){ e.preventDefault(); nudge(idx, -1); }
        if(e.key === 'ArrowDown'){ e.preventDefault(); nudge(idx, +1); }
        if(e.key === 'Home'){ e.preventDefault(); setValue(idx, 0, true); }
        if(e.key === 'End'){ e.preventDefault(); setValue(idx, 9, true); }
      });
    });

    function setReelOffset(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.reel');
      reel.style.transform = `translateY(${offset}px)`;
      reel.dataset.offset = offset;
    }

    function nudge(dialIndex, delta){
      const nextVal = mod(values[dialIndex] + delta, 10);
      setValue(dialIndex, nextVal, true);
    }

    function setValue(dialIndex, value, animate=true){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      if(animate){
        reel.style.transition = 'transform .12s ease-out';
        requestAnimationFrame(() => {
          setReelOffset(dialIndex, targetOffset);
          setTimeout(() => { reel.style.transition = ''; }, 140);
        });
      } else {
        setReelOffset(dialIndex, targetOffset);
      }

      values[dialIndex] = value;
      queueVerify(); // verifica asincrona
    }

    function snapToNearest(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const rawIndex = -(offset - centerY) / CELL_H;

      const value = mod(Math.round(rawIndex), 10);
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      reel.style.transition = 'transform .12s ease-out';
      requestAnimationFrame(() => {
        setReelOffset(dialIndex, targetOffset);
        setTimeout(() => { reel.style.transition = ''; }, 140);
      });

      values[dialIndex] = value;
      queueVerify(); // verifica asincrona
    }

    // ===============================
    //  Verifica SHA-256 lato client
    // ===============================
    let verifySeq = 0; // per considerare solo l'ultima verifica in corso

    function queueVerify(){
      const seq = ++verifySeq;
      verifyCurrentCode().then(ok => {
        if(seq !== verifySeq) return; // scarta verifiche vecchie
        chest.classList.toggle('unlocked', ok);
        statusEl.innerHTML = ok
          ? 'Stato: <span class="ok">Sbloccato</span>'
          : 'Stato: <span class="no">Bloccato</span>';
      });
    }

    async function verifyCurrentCode(){
      // Ricostruisco messaggio: pepper | codice | sig
      const code = values.join('');
      const msg  = P + '|' + code + '|' + S;
      const digestB64 = await sha256Base64(msg);
      return safeEqual(digestB64, H);
    }

    async function sha256Base64(str){
      const enc = new TextEncoder();
      const data = enc.encode(str);
      const buf  = await crypto.subtle.digest('SHA-256', data);
      // ArrayBuffer -> base64
      const bytes = new Uint8Array(buf);
      let binary = '';
      for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    function safeEqual(a,b){
      if (a.length !== b.length) return false;
      let r = 0;
      for (let i=0; i<a.length; i++) r |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return r === 0;
    }

    // ===============================
    //  Util
    // ===============================
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function mod(n,m){ return ((n % m) + m) % m; }

    // prima verifica su stato iniziale
    queueVerify();
  </script>
</body>
</html>
