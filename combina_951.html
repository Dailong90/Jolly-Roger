<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Enigma – Combinazione</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    :root { --bg-url: url('assets/temp_o2.png'); --ok:#10b981; --warn:#f59e0b; --err:#ef4444; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body{
      font-family:'Georgia','Times New Roman',serif; color:#2e2e2e;
      background:#000; min-height:100svh; position:relative;
    }
    body::before{ content:""; position:fixed; inset:0; background:var(--bg-url) center/cover no-repeat; z-index:-2; }
    body::after { content:""; position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:-1; }

    .wrap{
      position:fixed; left:50%; top:65svh; transform:translate(-50%,-50%);
      width:min(560px,92vw); padding:16px;
    }

    .card{
      display:flex; flex-direction:column; gap:10px;
      background:#fdf6e3; border:2px solid #d6c29e; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.45), inset 0 0 40px rgba(139,69,19,.25);
      background-image:
        radial-gradient(circle at top left, rgba(255,255,255,0.3), transparent 60%),
        radial-gradient(circle at bottom right, rgba(0,0,0,0.05), transparent 70%);
      max-height:58svh; overflow:hidden;
      transition: opacity .28s ease, transform .28s ease, visibility 0s linear .28s;
    }
    .card.is-hidden{ opacity:0; transform: translateY(10px) scale(.98); pointer-events:none; visibility:hidden; }
    .card:not(.is-hidden){ opacity:1; transform:none; visibility:visible; transition-delay:0s; }

    .btn--big{
      position: fixed; left:16px; bottom:16px; width:auto; margin:0;
      text-align:center; font-size:18px; padding:12px 16px; z-index:1000;
    }

    .head__actions{ display:flex; gap:8px; }
    .btn{
      cursor:pointer; border:1px solid #8b6b1b; border-radius:8px; padding:10px 14px; font-weight:700;
      background:linear-gradient(180deg,#f5d76e,#d4a017); color:#3b2c20; font-family:'Georgia',serif;
      box-shadow:0 3px 6px rgba(0,0,0,.4), inset 0 2px 4px rgba(255,255,255,.4);
      transition:transform .15s, box-shadow .15s; white-space:nowrap;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 5px 8px rgba(0,0,0,.5), inset 0 2px 4px rgba(255,255,255,.5); }
    .btn.btn--ghost{
      background:#efe6c7; border-color:#b2926d;
      box-shadow:0 2px 4px rgba(0,0,0,.2), inset 0 2px 3px rgba(255,255,255,.35);
    }

    .card__head{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:2px 4px 0; }
    .card__title{ margin:0; font-size:18px; line-height:1.2; color:#3b2c20; }

    .riddle{
      position:relative; border:1px dashed #b2926d; border-radius:8px; background:rgba(255,255,255,.65);
      display:grid; flex:1; min-height:0;
    }
    .riddle__scroller{
      grid-area:1 / 1; overflow:auto; -webkit-overflow-scrolling:touch;
      padding:14px 16px 32px; line-height:1.5; font-size:16px; color:#3b2c20; white-space:pre-wrap; min-height:0;
    }
    .riddle__fade{
      grid-area:1 / 1; align-self:end; height:84px;
      background:linear-gradient(to top, rgba(253,246,227,0.96), rgba(253,246,227,0));
      border-radius:0 0 8px 8px; pointer-events:none; z-index:2; opacity:1; transition:opacity .2s ease;
    }
    .riddle__indicator{
      grid-area:1 / 1; justify-self:center; align-self:end; transform:translateY(-10px);
      font-size:26px; color:#6b5b4b; z-index:3; pointer-events:none; animation:bounce 1.2s infinite; opacity:1; transition:opacity .2s ease;
    }
    @keyframes bounce { 0%,100%{ transform:translateY(-10px); } 50%{ transform:translateY(-4px); } }
    .riddle.--no-scroll .riddle__indicator { opacity:0; }

    /* ===== Modale ===== */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; align-items:center; justify-content:center; padding:4vw; z-index:999; }
    .modal.open{ display:flex; }
    .modal__inner{ position:relative; max-width:92vw; max-height:92vh; width:1200px; background:#111; border-radius:12px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.6); }
    .modal__close{ position:absolute; top:8px; right:8px; border:none; padding:8px 12px; line-height:1; background:#222; color:#f5d76e; font-weight:700; border-radius:8px; cursor:pointer; z-index:20; }
    .modal__close:hover{ background:#2f2f2f; }

    /* ====== CONTENUTO MODALE ====== */
    .lock-panel{
      position:relative; width:100%; padding:16px; background:#0e1216;
      display:grid; gap:16px; place-items:center; min-height:60vh;
    }

    /* === Timone (gate) === */
    .helm-gate{
      width:min(720px,92%); border-radius:16px; padding:12px 12px 10px;
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.20));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 10px 24px rgba(0,0,0,.45);
      color:#e5e7eb; margin:0 auto;
    }
    .helm-wrap{ position:relative; width:100%; display:grid; place-items:center; justify-items:center; padding:8px 8px 4px; }
    .helm-box{ position:relative; width:min(340px, 72vw); aspect-ratio:1/1; touch-action:none; margin:0 auto; }
    .helm-svg{ position:absolute; inset:0; width:100%; height:100%; }
    .helm-wheel{ transform-origin:50% 50%; transition:transform .1s ease-out; }
    .helm-arrow{
      position:absolute; left:50%; top:-10px; transform:translateX(-50%);
      width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent; border-bottom:20px solid #ef4444;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,.5));
    }
    .helm-label{ margin-top:6px; text-align:center; font-size:14px; opacity:.9; }

    /* Progress a 6 pallini */
    .helm-progress{ margin-top:8px; display:grid; grid-template-columns:repeat(6,1fr); gap:6px; width:min(360px, 82%); }
    .helm-progress span{
      display:block; height:10px; border-radius:999px; background:#374151;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);
      transition:background .18s ease, box-shadow .18s ease;
    }
    .helm-progress span.on     { background:var(--warn); box-shadow:0 0 8px rgba(245,158,11,.45), inset 0 0 0 1px rgba(255,255,255,.08); }
    .helm-progress span.success{ background:var(--ok);   box-shadow:0 0 10px rgba(16,185,129,.55), inset 0 0 0 1px rgba(255,255,255,.08); }

    /* === Card acciaio con rulli === */
    .lock-card{
      width:min(760px,92%); border-radius:20px; padding:12px; background:
        linear-gradient(180deg, #4b525b, #2f353d),
        repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.07), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.25), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow: 0 18px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 60px rgba(0,0,0,.25);
      outline: 1px solid rgba(255,255,255,.08);
      position:relative; margin:0 auto;
    }
    .lock-card.unlocked{
      box-shadow: 0 18px 40px rgba(0,0,0,.5), 0 0 0 2px rgba(16,185,129,.28), inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 60px rgba(0,0,0,.25);
      filter: drop-shadow(0 0 24px rgba(16,185,129,.25));
    }
    .lock-card__inner{
      border-radius:16px; padding:16px; background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 80px rgba(0,0,0,.25);
      position:relative;
    }

    /* Rulli: una riga */
    .lock-dials{ display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap:12px; width:100%; }
    .lock-dial{
      position:relative; height:clamp(110px, 20vw, 150px); border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.25));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.07), 0 6px 14px rgba(0,0,0,.45);
      overflow:hidden; user-select:none; touch-action:none; min-width:0;
    }
    .lock-dial::before, .lock-dial::after{ content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit; }
    .lock-dial::before{
      background:
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.20), rgba(0,0,0,0) 60%);
      mix-blend-mode: screen; z-index: 1;
    }
    .lock-dial::after{ background: linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,0) 28%, rgba(0,0,0,0) 72%, rgba(0,0,0,.35)); z-index: 3; }
    .lock-reel{
      position:absolute; left:0; right:0; top:0; z-index:2; will-change: transform;
      background:
        linear-gradient(180deg, #767b84, #4e545c),
        repeating-linear-gradient(0deg, rgba(255,255,255,.06) 0 1px, rgba(0,0,0,0) 1px 4px),
        radial-gradient(120% 100% at 50% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 60%),
        radial-gradient(120% 100% at 50% 70%, rgba(0,0,0,.18), rgba(0,0,0,0) 60%);
      background-blend-mode: overlay, normal, screen, multiply;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), inset 0 0 30px rgba(0,0,0,.25);
    }
    .lock-cell{
      height:clamp(38px, 6.5vw, 52px); display:grid; place-items:center;
      font-weight:800; font-variant-numeric: tabular-nums; font-size: clamp(24px, 6.2vw, 34px);
      color:#0f141a; text-shadow: 0 1px 0 rgba(255,255,255,.35), 0 2px 2px rgba(0,0,0,.15);
      border-top: 1px dashed rgba(15,20,26,.22); border-bottom: 1px dashed rgba(15,20,26,.22);
    }
    .lock-centerline{ position:absolute; left:8px; right:8px; top:50%; transform:translateY(-50%); height:0; border-top:1px dashed rgba(230,233,237,.45); z-index:4; }
    .lock-status{ margin-top:12px; text-align:center; font-size:.95rem; color:#e5e7eb; }
    .lock-status .ok{ color:var(--ok); font-weight:700; }
    .lock-status .no{ color:var(--err); font-weight:700; }
    .lock-actions{ margin-top:12px; text-align:center; }
    .lock-actions .btn{ min-width: 160px; }

    /* Gate: rulli bloccati finché il timone non è completo */
    .is-gated .lock-dials{ pointer-events:none; filter: blur(1.4px) grayscale(.4); }
    .lock-gate-mask{
      position:absolute; inset:0; display:grid; place-items:center; padding:16px; text-align:center;
      color:#e5e7eb; font-size:.95rem; background:linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.35));
      border-radius:16px; z-index:10; opacity:.95;
    }
    .gate-hidden .lock-gate-mask{ display:none; }
  </style>
  
</head>
<body>
  <main class="wrap">
    <button id="btnReveal" class="btn btn--big" aria-controls="contentCard" aria-expanded="false">
      Affronta la tempesta!
    </button>

    <section class="card is-hidden" id="contentCard" aria-hidden="true" aria-labelledby="titolo-regole">
      <div class="card__head">
        <h2 id="titolo-regole" class="card__title">Affronta la tempesta!</h2>
        <div class="head__actions">
          <button id="btnMap" type="button" class="btn" aria-haspopup="dialog" aria-controls="modalMap">Codice</button>
          <button id="btnHide" type="button" class="btn btn--ghost" aria-controls="contentCard">Nascondi</button>
        </div>
      </div>

      <div class="riddle" id="riddleBox">
        <div class="riddle__scroller" id="riddleScroll">
La tempesta impazza, non farti affondare!
Ma la rotta giusta dovrai ricordare.
Hai trovato qualcosa che non ti è servito?
Ora è il momento, non serve un'invito.
Fulmini scampati e non sai casa pensare?
Guarda dove ti trovi e saprai cosa fare.
Non sempre la soluzione può essere dedotta,
in queste situazioni basta non perdere la rotta.
        </div>
        <div class="riddle__fade" aria-hidden="true"></div>
        <div class="riddle__indicator" aria-hidden="true"><i class="bi bi-caret-down-fill"></i></div>
      </div>
    </section>
  </main>

  <!-- Modale -->
  <div id="modalMap" class="modal" role="dialog" aria-modal="true" aria-label="Inserisci il codice" aria-hidden="true">
    <div class="modal__inner">
      <button class="modal__close" type="button" id="btnClose" aria-label="Chiudi (Esc)">Chiudi ✕</button>

      <div class="lock-panel">
        <!-- === TIMONE (gate) === -->
        <section class="helm-gate" id="helmGate">
          <div class="helm-wrap">
            <div class="helm-box" id="helmBox" aria-label="Timone della nave">
              <div class="helm-arrow" aria-hidden="true"></div>

              <!-- SVG timone: bracci + lettere che ruotano insieme -->
              <svg class="helm-svg" viewBox="0 0 100 100" aria-hidden="false">
                <g id="helmWheel" class="helm-wheel">
                  <!-- dischi -->
                  <circle cx="50" cy="50" r="18" fill="#5b3b1a" stroke="#3a2715" stroke-width="1.2"/>
                  <circle cx="50" cy="50" r="25" fill="#7a4d22" stroke="#3a2715" stroke-width="1.2"/>
                  <!-- 8 manici -->
                  <g fill="#7a4d22" stroke="#3a2715" stroke-width="1">
                    <g transform="rotate(0 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g>   <!-- N -->
                    <g transform="rotate(45 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g>  <!-- NE -->
                    <g transform="rotate(90 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g>  <!-- E -->
                    <g transform="rotate(135 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g> <!-- SE -->
                    <g transform="rotate(180 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g> <!-- S -->
                    <g transform="rotate(225 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g> <!-- SW -->
                    <g transform="rotate(270 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g> <!-- W -->
                    <g transform="rotate(315 50 50)"><rect x="48.6" y="4" width="2.8" height="18" rx="1.4"/></g> <!-- NW -->
                  </g>
                  <!-- ghiera -->
                  <circle cx="50" cy="50" r="34" fill="none" stroke="#2a1b0d" stroke-width="4"/>
                  <circle cx="50" cy="50" r="30" fill="none" stroke="#b07a3c" stroke-width="2"/>
                  <circle cx="50" cy="50" r="12" fill="#5b3b1a" stroke="#3a2715" stroke-width="1.4"/>

                  <!-- Etichette legate ai bracci -->
                  <defs>
                    <filter id="labelShadow2" x="-50%" y="-50%" width="200%" height="200%">
                      <feDropShadow dx="0" dy="0" stdDeviation="0.6" flood-color="#000" flood-opacity="0.55"/>
                    </filter>
                  </defs>
                  <g font-size="6.5" font-weight="700" text-anchor="middle" dominant-baseline="middle" fill="#f8f4ec" filter="url(#labelShadow2)">
                    <g transform="rotate(0 50 50) translate(50 10)"><text>N</text></g>
                    <g transform="rotate(45 50 50) translate(50 10)"><text>NE</text></g>
                    <g transform="rotate(90 50 50) translate(50 10)"><text>E</text></g>
                    <g transform="rotate(135 50 50) translate(50 10)"><text>SE</text></g>
                    <g transform="rotate(180 50 50) translate(50 10)"><text>S</text></g>
                    <g transform="rotate(225 50 50) translate(50 10)"><text>SW</text></g>
                    <g transform="rotate(270 50 50) translate(50 10)"><text>W</text></g>
                    <g transform="rotate(315 50 50) translate(50 10)"><text>NW</text></g>
                  </g>
                </g>
              </svg>
            </div>

            <div class="helm-label" id="helmLabel">Scegli la rotta!</div>

            <!-- Progress a 6 pallini -->
            <div class="helm-progress" id="helmProgress" aria-live="polite">
              <span></span><span></span><span></span><span></span><span></span><span></span>
            </div>

            <!-- ▼▼ DEBUG (rimuovi in produzione) ▼▼ -->
            <div id="helmDebug" style="margin-top:6px;font-size:12px;color:#9ca3af;text-align:center"></div>
            <!-- ▲▲ DEBUG ▲▲ -->
          </div>
        </section>

        <!-- === CARD RULLI === -->
        <div id="lockCard" class="lock-card">
          <div class="lock-card__inner">
            <div class="lock-gate-mask" id="lockGateMask">
              <div>
                <div style="font-weight:700; margin-bottom:6px;">Supera la tempesta!</div>
                <div>Devi fuggire dalla tempesta per sbloccare i cilindri.</div>
              </div>
            </div>

            <div id="lockDials" class="lock-dials">
              <div class="lock-dial" data-index="0"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="1"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="2"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="3"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="4"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
              <div class="lock-dial" data-index="5"><div class="lock-reel"></div><div class="lock-centerline"></div></div>
            </div>

            <div id="lockStatus" class="lock-status" aria-live="polite">Stato: <span class="no">Bloccato</span></div>
            <div class="lock-actions">
              <a id="btnNext" class="btn" href="baia3t5.html" style="display:none;">Prosegui</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== Modale ===== */
    const btnMap   = document.getElementById('btnMap');
    const modal    = document.getElementById('modalMap');
    const btnClose = document.getElementById('btnClose');

    function openModal(){
      modal.classList.add('open');
      modal.setAttribute('aria-hidden','false');
      btnClose && btnClose.focus();
      initHelmOnce();  // timone
      initLockOnce();  // rulli
    }
    function closeModal(){
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden','true');
      btnMap && btnMap.focus();
    }
    btnMap.addEventListener('click', openModal);
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
    window.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.classList.contains('open')) closeModal(); });

    /* ===== Overlay scroll (card) ===== */
    const riddleBox = document.getElementById('riddleBox');
    const scroller  = document.getElementById('riddleScroll');
    function updateOverlay(){
      const canScroll = scroller.scrollHeight > scroller.clientHeight + 1;
      riddleBox.classList.toggle('--no-scroll', !canScroll);
      const atBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 1;
      riddleBox.classList.toggle('--at-bottom', atBottom);
    }
    scroller.addEventListener('scroll', updateOverlay);
    window.addEventListener('load', () => { requestAnimationFrame(updateOverlay); });
    window.addEventListener('resize', () => { requestAnimationFrame(updateOverlay); });

    /* ===== Reveal/Hide card ===== */
    (function(){
      const REVEAL_KEY = 'card_revealed_v1::' + location.pathname;
      const btnReveal = document.getElementById('btnReveal');
      const card = document.getElementById('contentCard');
      const btnHide = document.getElementById('btnHide');
      const title = document.getElementById('titolo-regole');

      function reveal(){
        card.classList.remove('is-hidden');
        card.setAttribute('aria-hidden','false');
        btnReveal.setAttribute('aria-expanded','true');
        btnReveal.style.display = 'none';
        btnHide.style.display = '';
        try{ localStorage.setItem(REVEAL_KEY, '1'); }catch{}
        if(title){ title.setAttribute('tabindex','-1'); title.focus(); }
      }
      function hide(){
        card.classList.add('is-hidden');
        card.setAttribute('aria-hidden','true');
        btnReveal.setAttribute('aria-expanded','false');
        btnReveal.style.display = 'block';
        btnHide.style.display = 'none';
        try{ localStorage.removeItem(REVEAL_KEY); }catch{}
        btnReveal.focus();
      }
      function init(){
        const wasRevealed = (()=>{ try{ return localStorage.getItem(REVEAL_KEY)==='1'; }catch{ return false; }})();
        if(wasRevealed){
          card.classList.remove('is-hidden'); card.setAttribute('aria-hidden','false');
          btnReveal.style.display = 'none'; btnReveal.setAttribute('aria-expanded','true'); btnHide.style.display = '';
        }else{
          card.classList.add('is-hidden'); card.setAttribute('aria-hidden','true');
          btnReveal.style.display = 'block'; btnReveal.setAttribute('aria-expanded','false'); btnHide.style.display = 'none';
        }
        btnReveal.addEventListener('click', reveal);
        btnReveal.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); reveal(); } });
        btnHide.addEventListener('click', hide);
      }
      init();
    })();

    /* ===================== TIMONE – Gate (6 step, solo pause da 2s) ===================== */
    // Sequenza target SE,NE,W,S,SW,N protetta (SHA-256 base64 spezzato)
    const HELM_H = (() => ['DV/J','wFCo','8sTe','OV7v','rCD8','vmRe','huTK','DSqq','QRx9','l0eT','vkY='].join(''))();
    const HELM_P = (() => ['GAL','-','RO','TA','-','8'].join(''))(); // Pepper
    const HELM_S = (() => ['HE','LM'].join(''))();                   // Signature
    const HELM_LEN = 6;

    const DIRS = ['N','NE','E','SE','S','SW','W','NW'];

    const helmBox = document.getElementById('helmBox');
    const helmWheel = document.getElementById('helmWheel');
    const helmProgress = document.getElementById('helmProgress');
    const helmLabel = document.getElementById('helmLabel');
    const helmDebug = document.getElementById('helmDebug');
    const lockCard = document.getElementById('lockCard');
    const lockGateMask = document.getElementById('lockGateMask');

    let helmInited = false;
    let holdTimer = null;
    let currentSector = null;       // 0..7
    let seqSoFar = [];              // es. ['SE','NE', ...]
    let hasMovedFromStart = false;  // conta solo dopo prima uscita dal settore iniziale
    let startSector = null;         // settore iniziale quando si apre la modale
    let countedInThisSector = false;// evita doppio conteggio senza spostarsi
    const HOLD_MS = 2000;           // 2 secondi di sosta

    function initHelmOnce(){
      if(helmInited){ updateHelmDebug(false); return; }

      // blocca i rulli
      lockCard.classList.add('is-gated');
      lockCard.classList.remove('gate-hidden');
      lockGateMask.style.display = '';
      resetProgress(); seqSoFar = [];
      hasMovedFromStart = false;
      startSector = null;
      countedInThisSector = false;
      updateHelmDebug(false);

      let dragging = false;

      const getCenter = () => {
        const r = helmBox.getBoundingClientRect();
        return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
      };
      const toDeg = (rad) => rad * 180 / Math.PI;

      // 0° = N; senso orario
      function angleFromCenter(x, y){
        const {cx, cy} = getCenter();
        const a = Math.atan2(y - cy, x - cx); // 0=E
        let deg = (toDeg(a) + 90);
        deg = (deg + 360) % 360;
        return deg;
      }
      const sectorFromAngle = (deg)=> Math.round(deg / 45) % 8;
      const snapRotationForSector = (sector)=> {
        // Ruota nel verso del dito
        helmWheel.style.transform = `rotate(${sector*45}deg)`;
      };

      function handleNewSector(sector){
        if(currentSector === null){
          currentSector = sector;
          if(startSector === null) startSector = sector;
          snapRotationForSector(sector);
          // niente timer finché non ci si è mossi almeno una volta
          return;
        }
        if(sector === currentSector) return;

        // Cambio settore
        currentSector = sector;
        snapRotationForSector(sector);
        countedInThisSector = false;    // posso contare di nuovo dopo il cambio
        if(holdTimer) clearTimeout(holdTimer);

        // Attiva "ha mosso" se lascia il settore iniziale
        if(!hasMovedFromStart && startSector !== null && sector !== startSector){
          hasMovedFromStart = true;
        }

        // Avvia il timer SOLO se c'è stato almeno un movimento dal settore iniziale
        if(hasMovedFromStart){
          holdTimer = setTimeout(onHoldStable, HOLD_MS, sector);
        }
      }

      async function onHoldStable(stableSector){
        // Deve essere ancora nello stesso settore
        if(stableSector !== currentSector) return;
        if(!hasMovedFromStart) return;          // non contare l'orientamento iniziale
        if(countedInThisSector) return;         // già contato in questo settore

        const activeIndex = (8 - stableSector) % 8;  // braccio che finisce sotto la freccia con rotate(+)
        const label = DIRS[activeIndex];

        // Registra il passo (solo feedback, verifica alla fine)
        seqSoFar.push(label);
        countedInThisSector = true;
        setProgress(seqSoFar.length, 'on');
        helmLabel.textContent = `Passo ${seqSoFar.length}/${HELM_LEN} registrato…`;
        updateHelmDebug(false);
        console.log('[HELM step]', seqSoFar.join(','));
        try { navigator.vibrate?.(18); } catch {}

        // Completati 6 tentativi → verifica unica
        if(seqSoFar.length === HELM_LEN){
          updateHelmDebug(true);
          console.log('[HELM final]', seqSoFar.join(','));
          const ok = await verifyHelmFinal(seqSoFar);
          if(ok){
            markProgressSuccess();
            lockCard.classList.remove('is-gated');
            lockCard.classList.add('gate-hidden');
            lockGateMask.style.display = 'none';
            helmLabel.textContent = 'Timone allineato. Inserisci il codice.';
            try { navigator.vibrate?.([20,40,20]); } catch {}
          }else{
            try { navigator.vibrate?.(60); } catch {}
            helmLabel.textContent = 'Sequenza errata. Ricomincia.';
            // piccola pausa per far vedere i 6 gialli, poi reset
            setTimeout(()=>{
              seqSoFar = [];
              resetProgress();
              countedInThisSector = false;
              hasMovedFromStart = false;          // chiedo di nuovo un movimento
              startSector = currentSector;        // l'attuale diventa "iniziale"
              updateHelmDebug(false);
              console.log('[HELM reset]');
            }, 500);
          }
        }
      }

      function updateHelmDebug(done=false){
        if(!helmDebug) return;
        const txt = seqSoFar.length
          ? `Inserito: ${seqSoFar.join(' , ')}${done ? ' (fine)' : ''}`
          : 'Inserito: —';
        helmDebug.textContent = txt;
      }

      function resetProgress(){
        [...helmProgress.children].forEach(el=> el.classList.remove('on','success'));
      }
      function setProgress(n, cls){
        const bars = [...helmProgress.children];
        bars.forEach((el,i)=>{ if(i < n){ el.classList.add(cls); } });
      }
      function markProgressSuccess(){
        const bars = [...helmProgress.children];
        bars.forEach(el=>{ el.classList.remove('on'); el.classList.add('success'); });
      }

      // Interazioni touch/pointer
      helmBox.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        helmBox.setPointerCapture?.(e.pointerId);
        const deg = angleFromCenter(e.clientX, e.clientY);
        const sec = sectorFromAngle(deg);
        if(currentSector === null){
          currentSector = sec;
          if(startSector === null) startSector = sec;
          snapRotationForSector(sec);
        }else if(sec !== currentSector){
          handleNewSector(sec);
        }
      });
      helmBox.addEventListener('pointermove', (e)=>{
        const deg = angleFromCenter(e.clientX, e.clientY);
        handleNewSector(sectorFromAngle(deg));
      });
      const endDrag = ()=>{
        if(hasMovedFromStart && currentSector!=null){
          if(holdTimer) clearTimeout(holdTimer);
          holdTimer = setTimeout(onHoldStable, HOLD_MS, currentSector);
        }
      };
      helmBox.addEventListener('pointerup', endDrag);
      helmBox.addEventListener('pointercancel', endDrag);
      helmBox.addEventListener('pointerleave', endDrag);

      helmInited = true;
    }

    // Verifica finale (tutta la sequenza)
    async function verifyHelmFinal(seqArray){
      const s = seqArray.join(',');                 // "SE,NE,W,S,SW,N"
      const digest = await sha256Base64(HELM_P + '|' + s + '|' + HELM_S);
      return safeEqual(digest, HELM_H);
    }

    /* ===================== RULLI (immutati) ===================== */
    const LOCK_H = (() => ['YfAr','gnE9','eUom','egxQ','F9uL','pudk','E2rA','63WW','/W1U','ksHf','dlQ='].join(''))();
    const LOCK_P = (() => ['GAL','LEON','-','14','92','-','RO','GER'].join(''))(); // GALLEON-1492-ROGER
    const LOCK_S = (() => ['BLA','CK','PE','AR','L'].join(''))();                // BLACKPEARL

    const lockStatus = document.getElementById('lockStatus');
    const btnNext    = document.getElementById('btnNext');
    const dialEls    = [];
    let lockInited   = false;

    let values = Array(6).fill(0);
    let CELL_H = 50;
    let verifySeq = 0;

    function initLockOnce(){
      if(lockInited){
        measureCellHeight();
        positionAllToCurrent();
        queueVerify();
        return;
      }
      const container = document.getElementById('lockDials');
      const dials = [...container.querySelectorAll('.lock-dial')];
      dials.forEach(d => dialEls.push(d));

      const baseDigits = Array.from({length:10}, (_,i)=>i);
      const loopDigits = [...baseDigits, ...baseDigits, ...baseDigits];
      dialEls.forEach(dial => {
        const reel = dial.querySelector('.lock-reel');
        reel.innerHTML = loopDigits.map(d => `<div class="lock-cell">${d}</div>`).join('');
      });

      measureCellHeight();
      values = Array(6).fill(0);
      dialEls.forEach((_, idx) => positionReelAtValue(idx, 0));

      dialEls.forEach((dial, idx) => {
        const reel = dial.querySelector('.lock-reel');
        let startY=0, startOffset=0, lastY=0, lastTime=0, velocity=0, dragging=false;

        const gatedGuard = (fn) => (e)=> {
          if(lockCard.classList.contains('is-gated')){ e.preventDefault(); return; }
          fn(e);
        };

        dial.addEventListener('pointerdown', gatedGuard((e) => {
          e.preventDefault();
          dial.setPointerCapture(e.pointerId);
          dragging = true;
          startY = e.clientY;
          startOffset = Number(reel.dataset.offset || 0);
          lastY = startY; lastTime = performance.now(); velocity = 0;
        }));
        dial.addEventListener('pointermove', (e) => {
          if(!dragging) return;
          const y = e.clientY;
          const dy = y - startY;
          const next = startOffset + dy;
          setReelOffset(idx, next);
          const now = performance.now(), dt = now - lastTime;
          if(dt>0) velocity = (y - lastY) / dt;
          lastY = y; lastTime = now;
        });
        dial.addEventListener('pointerup', () => {
          if(!dragging) return; dragging = false;
          const inertial = clamp(velocity, -0.9, 0.9) * CELL_H * 2;
          snapToNearest(idx, Number(reel.dataset.offset || 0) + inertial);
        });
        dial.addEventListener('pointercancel', () => {
          if(!dragging) return; dragging = false;
          snapToNearest(idx, Number(reel.dataset.offset || 0));
        });
        dial.addEventListener('wheel', (e) => {
          if(lockCard.classList.contains('is-gated')){ e.preventDefault(); return; }
          e.preventDefault(); nudge(idx, Math.sign(e.deltaY));
        }, {passive:false});
        dial.tabIndex = 0;
        dial.addEventListener('keydown', (e) => {
          if(lockCard.classList.contains('is-gated')){ e.preventDefault(); return; }
          if(e.key==='ArrowUp'){ e.preventDefault(); nudge(idx,-1); }
          if(e.key==='ArrowDown'){ e.preventDefault(); nudge(idx,+1); }
          if(e.key==='Home'){ e.preventDefault(); setValue(idx,0,true); }
          if(e.key==='End'){  e.preventPreventDefault(); setValue(idx,9,true); }
        });
      });

      queueVerify();
      lockInited = true;

      window.addEventListener('resize', () => {
        if(!modal.classList.contains('open')) return;
        measureCellHeight(); positionAllToCurrent(); queueVerify();
      });

      btnNext.addEventListener('click', (e) => {
        if(!btnNext.href) return;
        e.preventDefault();
        closeModal();
        setTimeout(()=>{ window.location.href = btnNext.href; }, 220);
      });
    }

    function measureCellHeight(){
      const any = document.querySelector('.lock-cell');
      if(any) CELL_H = any.getBoundingClientRect().height || 50;
    }
    function positionAllToCurrent(){ dialEls.forEach((_, i)=>positionReelAtValue(i, values[i] || 0)); }

    function positionReelAtValue(dialIndex, value){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const targetIndex = 10 + value;
      const translateY = -targetIndex * CELL_H + dial.getBoundingClientRect().height/2 - CELL_H/2;
      reel.style.transform = `translateY(${translateY}px)`;
      reel.dataset.offset = translateY;
      values[dialIndex] = value;
    }
    function setReelOffset(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      reel.style.transform = `translateY(${offset}px)`;
      reel.dataset.offset = offset;
    }
    function nudge(dialIndex, delta){
      const nextVal = mod(values[dialIndex] + delta, 10);
      setValue(dialIndex, nextVal, true);
    }
    function setValue(dialIndex, value, animate=true){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      if(animate){
        reel.style.transition = 'transform .12s ease-out';
        requestAnimationFrame(() => {
          setReelOffset(dialIndex, targetOffset);
          setTimeout(() => { reel.style.transition = ''; }, 140);
        });
      } else {
        setReelOffset(dialIndex, targetOffset);
      }
      values[dialIndex] = value;
      queueVerify();
    }
    function snapToNearest(dialIndex, offset){
      const dial = dialEls[dialIndex];
      const reel = dial.querySelector('.lock-reel');
      const dialH = dial.getBoundingClientRect().height;
      const centerY = dialH/2 - CELL_H/2;
      const rawIndex = -(offset - centerY) / CELL_H;

      const value = mod(Math.round(rawIndex), 10);
      const targetIndex = 10 + value;
      const targetOffset = -targetIndex * CELL_H + centerY;

      reel.style.transition = 'transform .12s ease-out';
      requestAnimationFrame(() => {
        setReelOffset(dialIndex, targetOffset);
        setTimeout(() => { reel.style.transition = ''; }, 140);
      });
      values[dialIndex] = value;
      queueVerify();
    }

    // === Util comuni ===
    async function sha256Base64(str){
      const enc = new TextEncoder();
      const data = enc.encode(str);
      const buf  = await crypto.subtle.digest('SHA-256', data);
      const bytes = new Uint8Array(buf);
      let binary = ''; for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function safeEqual(a,b){
      if (a.length !== b.length) return false;
      let r = 0; for (let i=0; i<a.length; i++) r |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return r === 0;
    }
    function queueVerify(){
      const seq = ++verifySeq;
      verifyCurrentCode().then(ok => {
        if(seq !== verifySeq) return;
        const effectiveOk = ok && !lockCard.classList.contains('is-gated');
        lockCard.classList.toggle('unlocked', effectiveOk);
        lockStatus.innerHTML = effectiveOk ? 'Stato: <span class="ok">Sbloccato</span>' : 'Stato: <span class="no">Bloccato</span>';
        btnNext.style.display = effectiveOk ? 'inline-block' : 'none';
      });
    }
    async function verifyCurrentCode(){
      const code = values.join('');
      const msg  = LOCK_P + '|' + code + '|' + LOCK_S;
      const digestB64 = await sha256Base64(msg);
      return safeEqual(digestB64, LOCK_H);
    }

    // Helpers
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function mod(n,m){ return ((n % m) + m) % m; }

   
    window._deriveHelmHash = async function(list, pepper, sig){
      const s = (pepper||HELM_P) + '|' + list.join(',') + '|' + (sig||HELM_S);
      const h = await sha256Base64(s);
      console.log('HelmHash base64:', h);
      return h;
    };
  </script>
</body>
</html>
