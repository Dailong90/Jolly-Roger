<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Enigma – Regole mappa mondo</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    :root { --bg-url: url('assets/jolly_bay.jpg'); }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body{
      font-family:'Georgia','Times New Roman',serif; color:#2e2e2e;
      background:#000; min-height:100svh; position:relative;
    }
    body::before{ content:""; position:fixed; inset:0; background:var(--bg-url) center/cover no-repeat; z-index:-2; }
    body::after { content:""; position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:-1; }

    .wrap{
      position:fixed; left:50%; top:65svh; transform:translate(-50%,-50%);
      width:min(560px,92vw); padding:16px;
    }

    .card{
      display:flex; flex-direction:column; gap:10px;
      background:#fdf6e3; border:2px solid #d6c29e; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.45), inset 0 0 40px rgba(139,69,19,.25);
      background-image:
        radial-gradient(circle at top left, rgba(255,255,255,0.3), transparent 60%),
        radial-gradient(circle at bottom right, rgba(0,0,0,0.05), transparent 70%);
      max-height:58svh;
    }

    /* Campo soluzione */
    .field{ display:flex; gap:10px; }
    #solveForm input[type="text"]{
      flex:1; background:#fff8e1;
      border:1px solid #b2926d; color:#2e2e2e;
      border-radius:8px; padding:12px 14px;
      outline:none; font-size:16px; height:46px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,.2);
    }
    #solveForm input[type="text"]:focus{
      border-color:#c9a85b; box-shadow:0 0 6px rgba(201,168,91,.6);
    }
    #solveForm button{
      cursor:pointer; border:1px solid #8b6b1b; border-radius:8px;
      padding:0 16px; font-weight:700; height:46px;
      background:linear-gradient(180deg,#f5d76e,#d4a017);
      color:#3b2c20; font-family:'Georgia', serif;
      box-shadow:0 3px 6px rgba(0,0,0,.4), inset 0 2px 4px rgba(255,255,255,.4);
      transition:transform .15s, box-shadow .15s;
    }
    #solveForm button:hover{
      transform:translateY(-1px);
      box-shadow:0 5px 8px rgba(0,0,0,.5), inset 0 2px 4px rgba(255,255,255,.5);
    }
    .tip{ font-size:12px; color:#6b5b4b; margin:6px 2px 0; font-style:italic; }
    .feedback{ margin-top:10px; font-weight:700; min-height:1.4em; text-align:center; }
    .ok{ color:#10b981; }  /* fallback se non usi --ok */
    .err{ color:#ef4444; } /* fallback se non usi --err */

    
    .card__head{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:2px 4px 0; }
    .card__title{ margin:0; font-size:18px; line-height:1.2; color:#3b2c20; }

    .riddle{
      position:relative; border:1px dashed #b2926d; border-radius:8px;
      background:rgba(255,255,255,.65);
      display:grid;
    }
    .riddle__scroller{
      grid-area:1 / 1; overflow:auto; -webkit-overflow-scrolling:touch;
      padding:14px 16px 32px; line-height:1.5; font-size:16px; color:#3b2c20; white-space:pre-wrap;
      max-height:40svh;
    }
    .riddle__fade{
      grid-area:1 / 1; align-self:end; height:84px;
      background:linear-gradient(to top, rgba(253,246,227,0.96), rgba(253,246,227,0));
      border-radius:0 0 8px 8px; pointer-events:none; z-index:2; opacity:1; transition:opacity .2s ease;
    }
    .riddle__indicator{
      grid-area:1 / 1; justify-self:center; align-self:end; transform:translateY(-10px);
      font-size:26px; color:#6b5b4b; z-index:3; pointer-events:none;
      animation:bounce 1.2s infinite; opacity:1; transition:opacity .2s ease;
    }
    @keyframes bounce { 0%,100%{ transform:translateY(-10px); } 50%{ transform:translateY(-4px); } }
    .riddle.--no-scroll .riddle__fade,
    .riddle.--no-scroll .riddle__indicator,
    .riddle.--at-bottom .riddle__fade,
    .riddle.--at-bottom .riddle__indicator { opacity:0; }

    .btn{
      cursor:pointer; border:1px solid #8b6b1b; border-radius:8px; padding:10px 14px; font-weight:700;
      background:linear-gradient(180deg,#f5d76e,#d4a017); color:#3b2c20; font-family:'Georgia',serif;
      box-shadow:0 3px 6px rgba(0,0,0,.4), inset 0 2px 4px rgba(255,255,255,.4);
      transition:transform .15s, box-shadow .15s; white-space:nowrap;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 5px 8px rgba(0,0,0,.5), inset 0 2px 4px rgba(255,255,255,.5); }

    /* Modale mappa */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; align-items:center; justify-content:center; padding:4vw; z-index:999; }
    .modal.open{ display:flex; }
    .modal__inner{ position:relative; max-width:92vw; max-height:92vh; width:1200px; background:#111; border-radius:12px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.6); }
    .modal__close{ position:absolute; top:8px; right:8px; border:none; padding:8px 12px; line-height:1; background:#222; color:#f5d76e; font-weight:700; border-radius:8px; cursor:pointer; z-index:20; }
    .modal__close:hover{ background:#2f2f2f; }

    /* Stage: mappa + layer adesivi */
    .stage { position:relative; width:100%; height:auto; }
    .modal__img{ display:block; width:100%; height:auto; max-height:92vh; object-fit:contain; background:#000; }

    .stickers { position:absolute; inset:0; overflow:visible; }

    .sticker{
      position:absolute;
      width: var(--sticker-w, 22px) !important; /* <— controllo via CSS var */
      height:auto;
      user-select:none; -webkit-user-drag:none; touch-action:none;
      cursor:grab; z-index:5;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,.5));
      transition: box-shadow .15s ease, width .15s ease;
    }
    .sticker:active{ cursor:grabbing; }
    .sticker.--dragging{ box-shadow:0 8px 18px rgba(0,0,0,.55); z-index:9; }

    .dock-hint{
      position:absolute; left:0; right:0; bottom:0; height:60px;
      background:linear-gradient(to top, rgba(0,0,0,.35), transparent);
      pointer-events:none; z-index:1;
    }

    /* Centra il contenuto (stage) dentro la finestra della modale */
    .modal__inner{
      display:flex;
      align-items:center;
      justify-content:center;
    }

  </style>
</head>
<body>
  <main class="wrap">
    <section class="card" aria-labelledby="titolo-regole">
      <div class="card__head">
        <h2 id="titolo-regole" class="card__title">Dannato vento!</h2>
        <button id="btnMap" type="button" class="btn" aria-haspopup="dialog" aria-controls="modalMap">Bacheca</button>
      </div>

      <div class="riddle" id="riddleBox">
        <div class="riddle__scroller" id="riddleScroll">
Cominciamo! Allora dobbiamo inserire la password... aspetta, non la ricordo! Tranquillo, ho un modo tutto mio per trovarla.
Nella mia cambusa ho una bacheca sul muro dove appendo le date in cui ho fatto i miei viaggi.
Oh no, il vento ha staccato tutti i fogli! 
Le città che ho visitato sono: Dakar, Katmandu, L'Avana, Montemiletto, Seattle, Teheran e Tokyo. 
Rimetti i fogli al loro posto secondo queste indicazioni:

-Teheran l'ho visitata dopo il 1991.
-Ho visto Tokyo 4 anni dopo Katmandu.
-A Dakar sono andato negli anni ’80.
-Tra Teheran e Tokyo, c'è solo una tappa in mezzo.
-L’Avana l'ho visitata dopo Teheran, ma non è negli anni 2000.
-Dopo Tokyo ho visto Seattle.
          
        </div>
        <div class="riddle__fade" aria-hidden="true"></div>
        <div class="riddle__indicator" aria-hidden="true"><i class="bi bi-caret-down-fill"></i></div>
      </div>
       <!-- Soluzione  -->
      <form id="solveForm" autocomplete="off">
        <div class="field">
          <input id="answer" name="answer" type="text" placeholder="Soluzione…" required />
          <button id="btnCheck" type="submit">Verifica</button>
        </div>
        <div id="feedback" class="feedback" aria-live="polite"></div>
      </form>
    </section>
  </main>

  <!-- Modale mappa -->
  <div id="modalMap" class="modal" role="dialog" aria-modal="true" aria-label="Mappa del mondo" aria-hidden="true">
    <div class="modal__inner">
      <button class="modal__close" type="button" id="btnClose" aria-label="Chiudi (Esc)">Chiudi ✕</button>
      <div class="stage" id="stage">
        <img class="modal__img" id="mapImg" src="assets/world_map.png" alt="Mappa del mondo" />
        <div class="stickers" id="stickers"></div>
        <div class="dock-hint" aria-hidden="true"></div>
      </div>
    </div>
  </div>

  <script>
    /* ===== Modale ===== */
    const btnMap   = document.getElementById('btnMap');
    const modal    = document.getElementById('modalMap');
    const btnClose = document.getElementById('btnClose');

    function openModal(){ 
      modal.classList.add('open'); 
      modal.setAttribute('aria-hidden','false'); 
      btnClose && btnClose.focus(); 
      ensureStickersInitialized();
    
      // 🔒 BLOCCA le dimensioni visibili attuali (aggiunta)
      const w = mapImg.getBoundingClientRect().width;
      const h = mapImg.getBoundingClientRect().height;
      mapImg.style.width = w + 'px';
      mapImg.style.height = h + 'px';
      mapImg.style.maxWidth = 'none';
      mapImg.style.maxHeight = 'none';
      stage.style.width = w + 'px';
      stage.style.height = 'auto';
      stage.style.margin = '0 auto';  // centra orizzontalmente
    }

    function closeModal(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); btnMap && btnMap.focus(); }
    btnMap.addEventListener('click', openModal);
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
    window.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.classList.contains('open')) closeModal(); });

    /* ===== Overlay scroll ===== */
    const riddleBox = document.getElementById('riddleBox');
    const scroller  = document.getElementById('riddleScroll');
    function updateOverlay(){
      const canScroll = scroller.scrollHeight > scroller.clientHeight + 1;
      riddleBox.classList.toggle('--no-scroll', !canScroll);
      const atBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 1;
      riddleBox.classList.toggle('--at-bottom', atBottom);
    }
    scroller.addEventListener('scroll', updateOverlay);
    window.addEventListener('load', () => { requestAnimationFrame(updateOverlay); });
    window.addEventListener('resize', () => { requestAnimationFrame(updateOverlay); });

    /* ===== Stickers (drag & drop + persistenza) ===== */
    const stage      = document.getElementById('stage');
    const stickersEl = document.getElementById('stickers');
    const mapImg     = document.getElementById('mapImg');
    const IMGS = [1,2,3,4,5,6,7].map(i => ({ id:`perg_${i}`, src:`assets/perg_${i}.png` }));
    const STORAGE_KEY = 'perg_positions_v1';
    let zCounter = 10;
    let initialized = false;

    function readSaved(){
      try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); }catch{ return null; }
    }
    function savePositions(){
      const rect = stage.getBoundingClientRect();
      const data = IMGS.map(({id})=>{
        const el = document.getElementById(id);
        if(!el) return {id, xPct:0, yPct:0};
        const srect = el.getBoundingClientRect();
        const left = srect.left - rect.left;
        const top  = srect.top  - rect.top;
        const xPct = (left) / Math.max(1, (rect.width - srect.width));
        const yPct = (top)  / Math.max(1, (rect.height - srect.height));
        return { id, xPct: Math.min(Math.max(xPct,0),1), yPct: Math.min(Math.max(yPct,0),1) };
      });
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }
    function placeByPercent(el, xPct, yPct){
      const rect = stage.getBoundingClientRect();
      const sw   = el.offsetWidth;
      const sh   = el.offsetHeight;
      const left = xPct * Math.max(0, rect.width  - sw);
      const top  = yPct * Math.max(0, rect.height - sh);
      el.style.left = `${left}px`;
      el.style.top  = `${top}px`;
    }

    // Calcola una larghezza che consenta 7 sticker in fila con gap
    function computeStickerWidth(){
      const rect = stage.getBoundingClientRect();
      const gap = 12;
      const n = IMGS.length;
      // un piccolo padding di sicurezza ai lati
      const safe = 16;
      const w = Math.floor((rect.width - safe*2 - gap*(n-1)) / n);
      // limiti ragionevoli (min 64px, max 160px)
      return Math.max(22, Math.min(22, w));
    }

    function initialDockLayout(){
      const gap = 12;
      const w = computeStickerWidth();
      // imposta la width coerente per tutte le pergamene
      IMGS.forEach(({id})=>{
        const el = document.getElementById(id);
        el.style.setProperty('--sticker-w', `${w}px`);
      });

      const rect = stage.getBoundingClientRect();
      const totalW = w*IMGS.length + gap*(IMGS.length-1);
      let curX = Math.max(8, Math.floor((rect.width - totalW)/2));
      const y = Math.max(0, rect.height - (w * 0.75) - 12); // poco sopra il bordo

      IMGS.forEach(({id})=>{
        const el = document.getElementById(id);
        el.style.left = `${curX}px`;
        el.style.top  = `${y}px`;
        curX += w + gap;
      });
    }

    function createSticker({id, src}){
      const img = document.createElement('img');
      img.id = id;
      img.src = src;
      img.alt = id;
      img.className = 'sticker';
      img.draggable = false;
      stickersEl.appendChild(img);
      enableDrag(img);
      return img;
    }

    function enableDrag(el){
      let startX=0, startY=0, origLeft=0, origTop=0, dragging=false;

      function onPointerDown(e){
        e.preventDefault();
        el.classList.add('--dragging');
        el.setPointerCapture(e.pointerId);
        dragging = true;
        const rect = el.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        origLeft = rect.left;
        origTop  = rect.top;
        el.style.zIndex = ++zCounter;
      }

      function onPointerMove(e){
        if(!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        const stageRect = stage.getBoundingClientRect();
        const selfRect  = el.getBoundingClientRect();

        let newLeft = origLeft + dx - stageRect.left;
        let newTop  = origTop  + dy - stageRect.top;

        newLeft = Math.min(Math.max(0, newLeft), stageRect.width  - selfRect.width);
        newTop  = Math.min(Math.max(0, newTop ), stageRect.height - selfRect.height);

        el.style.left = `${newLeft}px`;
        el.style.top  = `${newTop}px`;
      }

      function onPointerUp(e){
        if(!dragging) return;
        dragging = false;
        el.releasePointerCapture(e.pointerId);
        el.classList.remove('--dragging');
        savePositions();
      }

      el.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    }

    function ensureStickersInitialized(){
      if(initialized) return;
      const doInit = ()=>{
        IMGS.forEach(obj => createSticker(obj));

        const saved = readSaved();
        const w = computeStickerWidth();
        IMGS.forEach(({id})=>{
          const el = document.getElementById(id);
          el.style.setProperty('--sticker-w', `${w}px`);
        });

        if(saved && Array.isArray(saved)){
          saved.forEach(({id,xPct,yPct})=>{
            const el = document.getElementById(id);
            if(el) placeByPercent(el, xPct ?? 0, yPct ?? 0);
          });
        }else{
          initialDockLayout();
          savePositions();
        }
        initialized = true;
      };

      if (mapImg.complete) {
        requestAnimationFrame(doInit);
      } else {
        mapImg.addEventListener('load', () => requestAnimationFrame(doInit), { once:true });
      }
    }

    // Su resize: ricalcolo la width e riposiziono
    // window.addEventListener('resize', ()=>{
    //   if(!initialized) return;
    //   const w = computeStickerWidth();
    
    //   IMGS.forEach(({id})=>{
    //     const el = document.getElementById(id);
    //     if(el) el.style.setProperty('--sticker-w', `${w}px`); // <— QUI la differenza
    //   });
    
    //   const saved = readSaved();
    //   if(saved){
    //     saved.forEach(({id,xPct,yPct})=>{
    //       const el = document.getElementById(id);
    //       if(el) placeByPercent(el, xPct ?? 0, yPct ?? 0);
    //     });
    //   }
    // });


    // Init overlay after load
    window.addEventListener('load', () => { requestAnimationFrame(updateOverlay); });

    /* ===== Verifica soluzione (hash) */
    const HASH_EXPECTED = "c7cf3eceaa976b81bbdcccaf70937a47a8f3906971534c2579a09d41724344c5";
    // Se vuoi un redirect al successo, metti qui l'URL (altrimenti stringa vuota):
    const SUCCESS_URL = "jr2025.html";
    
    async function sha256Hex(input) {
      const enc = new TextEncoder().encode(input);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2,'0')).join('');
    }
    
    const form = document.getElementById('solveForm');
    const input = document.getElementById('answer');
    const feedback = document.getElementById('feedback');
    
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      feedback.textContent = '';
      const value = input.value;            // ← NIENTE normalize/trim
      if (value.length === 0) return;
    
      const hash = await sha256Hex(value);  // hash del valore esatto
      if (hash === HASH_EXPECTED) {
        feedback.textContent = '✅ Corretto!';
        feedback.className = 'feedback ok';
        if (SUCCESS_URL) setTimeout(()=>{ window.location.href = SUCCESS_URL; }, 600);
      } else {
        feedback.textContent = '❌ Errato. Riprova!';
        feedback.className = 'feedback err';
      }
    });

    
    // Invio con Enter
    input.addEventListener('keydown', (e) => { if (e.key === 'Enter') form.requestSubmit(); });

    
  </script>
</body>
</html>
